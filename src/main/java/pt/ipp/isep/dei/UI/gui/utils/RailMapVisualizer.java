package pt.ipp.isep.dei.UI.gui.utils;

import javafx.animation.AnimationTimer;
import javafx.animation.ScaleTransition;
import javafx.geometry.Insets;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.ToggleButton;
import javafx.scene.effect.DropShadow;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.util.Duration;
import pt.ipp.isep.dei.domain.Train;

import java.text.Normalizer;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.regex.Pattern;

public class RailMapVisualizer extends StackPane {

    // --- COMPONENTES UI ---
    private final Canvas canvas;
    private final Pane canvasPane;
    private final VBox notificationPanel;
    private VBox notificationContent;
    private Button notificationToggle;

    private final VBox conflictPanel;
    private final VBox successPanel;

    // --- DADOS ---
    private final Map<String, Point2D> stationCoordinates = new HashMap<>();
    private final Map<String, Point2D> autoGeneratedCoordinates = new HashMap<>();
    private final List<VisualSegment> segments = new ArrayList<>();
    private final List<VisualTrain> allTrains = new ArrayList<>();
    private final Map<String, ConflictInfo> conflictRegistry = new HashMap<>();

    // --- C√ÇMARA ---
    private double scale = 0.55;
    private double translateX = 0, translateY = 0;
    private double targetScale = 0.55;
    private double targetTranslateX = 0, targetTranslateY = 0;
    private boolean autoCameraMode = true;
    private double lastMouseX, lastMouseY;

    // --- SIMULA√á√ÉO ---
    private LocalTime simulationTime;
    private LocalTime maxSimulationTime;
    private double speedFactor = 50.0;
    private double userSpeedSetting = 50.0;
    private AnimationTimer timer;
    private boolean isFinished = false;

    // --- ESTADO CR√çTICO ---
    private boolean isPausedByConflict = false;
    private boolean isSlowMotionReplay = false;
    private VisualTrain conflictFocusTrain = null;
    private long slowMotionEndTime = 0;

    // --- CONTROLOS ---
    private final Button btnZoomIn, btnZoomOut;
    private final ToggleButton btnAutoCam;
    private final Label clockLabel;

    public RailMapVisualizer() {
        this.setStyle("-fx-background-color: #0b1120;");

        // 1. Layer Mapa
        this.canvasPane = new Pane();
        this.canvas = new Canvas(2500, 3500); // Canvas grande para caber tudo
        this.canvasPane.getChildren().add(canvas);
        canvas.widthProperty().bind(this.widthProperty());
        canvas.heightProperty().bind(this.heightProperty());

        setupGeographicallyAccurateMap(); // MAPA COMPLETO USBD32

        // 2. Layer HUD
        this.notificationPanel = createNotificationPanel();

        // 3. Layer Rel√≥gio
        this.clockLabel = new Label("00:00:00");
        this.clockLabel.setStyle("-fx-text-fill: white; -fx-font-family: 'Monospaced'; -fx-font-size: 28px; -fx-font-weight: bold; -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.8), 5, 0, 0, 1);");

        // 4. Controlos
        this.btnZoomIn = createGlassButton("+");
        this.btnZoomIn.setOnAction(e -> manualZoom(1.2));
        this.btnZoomOut = createGlassButton("-");
        this.btnZoomOut.setOnAction(e -> manualZoom(0.8));

        this.btnAutoCam = new ToggleButton("AUTO CAM");
        this.btnAutoCam.setSelected(true);
        this.btnAutoCam.setStyle("-fx-background-color: rgba(16, 185, 129, 0.2); -fx-text-fill: #10b981; -fx-font-weight: bold; -fx-border-color: rgba(16, 185, 129, 0.4); -fx-border-radius: 5;");
        this.btnAutoCam.selectedProperty().addListener((obs, old, isSelected) -> autoCameraMode = isSelected);

        HBox controlsBox = new HBox(10, btnAutoCam, btnZoomOut, btnZoomIn);
        controlsBox.setAlignment(Pos.TOP_RIGHT);
        controlsBox.setPadding(new Insets(20));
        controlsBox.setPickOnBounds(false);

        // 5. Pain√©is
        this.conflictPanel = createConflictPanel();
        this.successPanel = createSuccessPanel();

        this.getChildren().addAll(canvasPane, clockLabel, notificationPanel, controlsBox, conflictPanel, successPanel);

        // Posicionamento
        StackPane.setAlignment(clockLabel, Pos.TOP_CENTER);
        StackPane.setMargin(clockLabel, new Insets(25, 0, 0, 0));
        StackPane.setAlignment(notificationPanel, Pos.TOP_LEFT);
        StackPane.setMargin(notificationPanel, new Insets(20, 0, 0, 20));
        StackPane.setAlignment(controlsBox, Pos.TOP_RIGHT);
        StackPane.setAlignment(conflictPanel, Pos.CENTER);
        StackPane.setAlignment(successPanel, Pos.CENTER);

        setupInteraction();
    }

    // --- MAPA ATUALIZADO (USBD32 COMPLETO) ---
    private void setupGeographicallyAccurateMap() {
        // Eixo Y: Cresce para Baixo (Norte no topo -> 0, Sul em baixo -> 1000+)
        // Eixo X: Cresce para Direita (Oeste/Mar -> 0, Este/Interior -> 1000+)

        // --- EXTREMO NORTE (Fronteira) ---
        addStation("Valenca", 400, 100);
        addStation("Sao Pedro da Torre", 390, 160);
        addStation("Vila Nova da Cerveira", 370, 220);
        addStation("Carvalha", 360, 260); // Perto de Caminha
        addStation("Caminha", 350, 300);

        // --- ZONA VIANA DO CASTELO ---
        addStation("Carreco", 340, 360);
        addStation("Viana do Castelo", 340, 420);
        addStation("Darque", 360, 440);
        addStation("Barroselas", 380, 490);

        // --- ZONA BARCELOS / NINE ---
        addStation("Tamel", 400, 540);
        addStation("Barcelos", 410, 580);
        addStation("Midoes", 430, 620);
        addStation("Nine", 450, 660); // N√ì PRINCIPAL (Minho vs Braga)

        // --- RAMAL DE BRAGA & EXTENS√ÉO (Leste de Nine) ---
        // A linha vai para a direita (Este)
        addStation("Tadim", 520, 650); // Opcional, mas d√° escala
        addStation("Braga", 580, 640);

        // Extens√£o "Fict√≠cia" USBD32 (Continua para Norte/Leste de Braga)
        addStation("Manzagao", 640, 620);
        addStation("Cerqueiral", 680, 590);
        addStation("Gemieira", 720, 560);
        addStation("Paredes de Coura", 650, 450); // Liga de volta ao norte (teoricamente)

        // --- DESCENDO PARA O PORTO (Sul de Nine) ---
        addStation("Lousado", 450, 720); // N√≥ de Guimar√£es
        addStation("Senhora das Dores", 480, 710); // Perto de Lousado (Ramal Guimar√£es)
        addStation("Famalicao", 450, 760);
        addStation("Sao Frutuoso", 450, 800);
        addStation("Leandro", 450, 830);
        addStation("Sao Romao", 450, 860);

        // --- ZONA GRANDE PORTO ---
        addStation("Ermesinde", 460, 920); // N√≥ do Douro

        // Linha de Cintura / Leix√µes (Oeste de Ermesinde/Contumil)
        addStation("Sao Gemil", 420, 940);
        addStation("Sao Mamede de Infesta", 380, 940);
        addStation("Leca do Balio", 340, 930);
        addStation("Leixoes", 290, 920); // Porto de Leix√µes (Carga)

        // Entrada na cidade
        addStation("Contumil", 460, 960);
        addStation("Porto Campanha", 440, 1000); // Principal
        addStation("Porto Sao Bento", 400, 1020); // T√©rmino no centro

        // --- SUL DO DOURO (Contexto) ---
        addStation("General Torres", 440, 1050);
        addStation("Vila Nova de Gaia", 440, 1080);
    }

    // --- (RESTO DO C√ìDIGO INALTERADO) ---

    private VBox createNotificationPanel() {
        VBox container = new VBox(5);
        container.setMaxWidth(250);
        container.setPickOnBounds(false);

        notificationToggle = new Button("üìÑ LOG");
        notificationToggle.setFont(Font.font("System", FontWeight.BOLD, 10));
        notificationToggle.setStyle("-fx-background-color: rgba(30, 41, 59, 0.8); -fx-text-fill: #94a3b8; -fx-background-radius: 4; -fx-border-color: #475569; -fx-border-radius: 4; -fx-cursor: hand; -fx-padding: 4 8;");

        notificationContent = new VBox(5);
        notificationContent.setPadding(new Insets(8));
        notificationContent.setStyle("-fx-background-color: rgba(15, 23, 42, 0.95); -fx-background-radius: 4; -fx-border-color: #475569; -fx-border-width: 1;");

        ScrollPane scroll = new ScrollPane(notificationContent);
        scroll.setFitToWidth(true);
        scroll.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        scroll.setStyle("-fx-background: transparent; -fx-background-color: transparent;");
        scroll.setMaxHeight(200);

        VBox contentWrapper = new VBox(scroll);
        contentWrapper.setVisible(false);
        contentWrapper.setManaged(false);

        notificationToggle.setOnAction(e -> {
            boolean isVisible = contentWrapper.isVisible();
            contentWrapper.setVisible(!isVisible);
            contentWrapper.setManaged(!isVisible);
            if (!isVisible) {
                notificationToggle.setStyle("-fx-background-color: #10b981; -fx-text-fill: white; -fx-background-radius: 4; -fx-padding: 4 8;");
                notificationToggle.setText("‚úñ FECHAR");
            } else {
                notificationToggle.setStyle("-fx-background-color: rgba(30, 41, 59, 0.8); -fx-text-fill: #94a3b8; -fx-background-radius: 4; -fx-border-color: #475569; -fx-border-radius: 4; -fx-padding: 4 8;");
                notificationToggle.setText("üìÑ LOG");
            }
        });

        container.getChildren().addAll(notificationToggle, contentWrapper);
        return container;
    }

    private VBox createSuccessPanel() {
        VBox panel = new VBox(15);
        panel.setAlignment(Pos.CENTER);
        panel.setMaxSize(500, 320);
        panel.setStyle("-fx-background-color: rgba(6, 78, 59, 0.95); -fx-background-radius: 15; -fx-border-color: #10b981; -fx-border-width: 3; -fx-effect: dropshadow(three-pass-box, rgba(16, 185, 129, 0.4), 50, 0, 0, 0);");

        Label icon = new Label("‚úî SUCESSO");
        icon.setStyle("-fx-text-fill: #10b981; -fx-font-size: 32px; -fx-font-weight: bold; -fx-effect: dropshadow(gaussian, black, 2, 1, 0, 0);");
        Label title = new Label("SIMULA√á√ÉO TERMINADA");
        title.setStyle("-fx-text-fill: white; -fx-font-size: 22px; -fx-font-weight: bold;");
        Label desc = new Label("Todos os conflitos foram resolvidos e os hor√°rios cumpridos.");
        desc.setStyle("-fx-text-fill: #d1fae5; -fx-font-size: 16px; -fx-text-alignment: center;");
        desc.setWrapText(true);
        Button btnRestart = new Button("FECHAR / REINICIAR");
        btnRestart.setStyle("-fx-background-color: #10b981; -fx-text-fill: white; -fx-font-weight: bold; -fx-padding: 12 30; -fx-background-radius: 8; -fx-cursor: hand; -fx-font-size: 14px;");
        btnRestart.setOnAction(e -> panel.setVisible(false));

        panel.getChildren().addAll(icon, title, desc, btnRestart);
        panel.setVisible(false);
        return panel;
    }

    private void showSuccessPanel() {
        if (!successPanel.isVisible()) {
            successPanel.setVisible(true);
            successPanel.toFront();
            ScaleTransition st = new ScaleTransition(Duration.millis(500), successPanel);
            st.setFromX(0.5); st.setFromY(0.5); st.setToX(1.0); st.setToY(1.0); st.play();
        }
    }

    public void addLog(String msg, boolean isCritical) {
        Label lbl = new Label((isCritical ? "‚ö† " : "‚û§ ") + msg);
        lbl.setWrapText(true);
        lbl.setMaxWidth(220);
        lbl.setFont(Font.font("Segoe UI", FontWeight.NORMAL, 11));
        if (isCritical) {
            lbl.setStyle("-fx-text-fill: #ff6b6b; -fx-font-weight: bold; -fx-background-color: rgba(255,0,0,0.15); -fx-padding: 3; -fx-background-radius: 3;");
        } else {
            lbl.setStyle("-fx-text-fill: #cbd5e1; -fx-padding: 2;");
        }
        notificationContent.getChildren().add(0, lbl);
        if (notificationContent.getChildren().size() > 30) notificationContent.getChildren().remove(30, notificationContent.getChildren().size());
    }

    private Point2D getCoordinates(String name) {
        String key = normalize(name);
        if (stationCoordinates.containsKey(key)) return stationCoordinates.get(key);
        for (String k : stationCoordinates.keySet()) if (k.contains(key) || key.contains(k)) return stationCoordinates.get(k);
        if (!autoGeneratedCoordinates.containsKey(key)) {
            double autoX = 150;
            double autoY = 400 + (autoGeneratedCoordinates.size() * 30);
            autoGeneratedCoordinates.put(key, new Point2D(autoX, autoY));
        }
        return autoGeneratedCoordinates.get(key);
    }

    private String normalize(String s) {
        if (s == null) return "";
        String temp = Normalizer.normalize(s, Normalizer.Form.NFD);
        Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+");
        return pattern.matcher(temp).replaceAll("").toLowerCase().trim()
                .replace(" - ", " ").replace("-", " ")
                .replace("√ß", "c").replace("√£", "a").replace("√µ", "o").replace("√©", "e")
                .replace("√≠", "i").replace("√°", "a").replace("√¢", "a");
    }

    private void addStation(String name, double x, double y) {
        stationCoordinates.put(normalize(name), new Point2D(x, y));
    }

    private Button createGlassButton(String text) {
        Button btn = new Button(text);
        btn.setStyle("-fx-background-color: rgba(255, 255, 255, 0.1); -fx-text-fill: white; -fx-font-weight: bold; -fx-min-width: 30px; -fx-background-radius: 5; -fx-border-color: rgba(255,255,255,0.2);");
        return btn;
    }

    private VBox createConflictPanel() {
        VBox panel = new VBox(15);
        panel.setAlignment(Pos.CENTER);
        panel.setMaxSize(480, 300);
        panel.setStyle("-fx-background-color: rgba(15, 23, 42, 0.98); -fx-background-radius: 15; -fx-border-color: #ef4444; -fx-border-width: 3; -fx-effect: dropshadow(three-pass-box, rgba(239, 68, 68, 0.6), 80, 0, 0, 0);");

        Label icon = new Label("‚ö† COLIS√ÉO EVITADA");
        icon.setStyle("-fx-text-fill: #ef4444; -fx-font-size: 26px; -fx-font-weight: bold;");
        Label desc = new Label("Sistemas de seguran√ßa ativados.");
        desc.setId("conflictDesc");
        desc.setStyle("-fx-text-fill: #cbd5e1; -fx-font-size: 16px; -fx-text-alignment: center;");
        desc.setWrapText(true);
        Button btn = new Button("VISUALIZAR A√á√ÉO (Retomar)");
        btn.setStyle("-fx-background-color: white; -fx-text-fill: #0f172a; -fx-font-weight: bold; -fx-padding: 12 25; -fx-background-radius: 20; -fx-cursor: hand; -fx-font-size: 14px;");
        btn.setOnAction(e -> {
            panel.setVisible(false);
            isPausedByConflict = false;
            isSlowMotionReplay = true;
            speedFactor = 1.0;
            slowMotionEndTime = System.currentTimeMillis() + 3000;
            addLog("‚ñ∂ Retomando tr√°fego...", false);
        });
        panel.getChildren().addAll(icon, desc, btn);
        panel.setVisible(false);
        return panel;
    }

    public void loadSchedule(Map<Train, List<String>> trainSchedules, LocalTime time) {
        segments.clear();
        allTrains.clear();
        conflictRegistry.clear();
        notificationContent.getChildren().clear();
        conflictPanel.setVisible(false);
        successPanel.setVisible(false);
        isFinished = false;

        LocalTime minT = LocalTime.MAX;
        LocalTime maxT = LocalTime.MIN;

        for (List<String> logs : trainSchedules.values()) {
            for (String line : logs) {
                if (line.startsWith("!!!CONFLICT")) {
                    String[] parts = line.split("\\|");
                    if (parts.length >= 4) {
                        conflictRegistry.put(parts[1], new ConflictInfo(parts[2], Integer.parseInt(parts[3])));
                    }
                }
            }
        }

        for (Map.Entry<Train, List<String>> entry : trainSchedules.entrySet()) {
            Train train = entry.getKey();
            VisualTrain vt = new VisualTrain(train);
            boolean hasData = false;

            for (String logLine : entry.getValue()) {
                if (logLine.startsWith("!!!")) continue;
                String[] parts = logLine.split("\\|");
                if (parts.length < 7) continue;

                try {
                    String startSt = parts[1].trim();
                    String endSt = parts[2].trim();
                    if (parts[5].trim().equals("N/A") || parts[6].trim().equals("N/A")) continue;

                    LocalTime in = LocalTime.parse(parts[5].trim());
                    LocalTime out = LocalTime.parse(parts[6].trim());

                    if (in.isBefore(minT)) minT = in;
                    if (out.isAfter(maxT)) maxT = out;

                    Point2D p1 = getCoordinates(startSt);
                    Point2D p2 = getCoordinates(endSt);

                    if (segments.stream().noneMatch(s -> s.matches(startSt, endSt))) {
                        boolean isDouble = parts[3].toLowerCase().contains("double");
                        segments.add(new VisualSegment(startSt, endSt, p1, p2, isDouble));
                    }
                    vt.addMovement(in, out, p1, p2, startSt, endSt);
                    hasData = true;
                } catch (Exception e) {}
            }

            if (hasData) {
                ConflictInfo c = conflictRegistry.get(train.getTrainId());
                if (c != null && !vt.movements.isEmpty()) {
                    vt.initialDelayMinutes = c.delayMinutes;
                    vt.hasInitialConflict = true;
                    vt.scheduledStart = vt.movements.get(0).start.minusMinutes(c.delayMinutes);
                }
                allTrains.add(vt);
            }
        }

        this.simulationTime = (minT == LocalTime.MAX) ? LocalTime.of(8, 0) : minT.minusMinutes(30);
        this.maxSimulationTime = maxT.plusMinutes(30);

        autoCameraMode = true;
        btnAutoCam.setSelected(true);
        scale = 0.55;
        updateFrame();
        addLog("Rede carregada.", false);
    }

    public void startAnimation() {
        if (timer != null) timer.stop();
        if (allTrains.isEmpty()) return;

        timer = new AnimationTimer() {
            private long lastUpdate = 0;
            @Override
            public void handle(long now) {
                if (lastUpdate == 0) { lastUpdate = now; return; }
                double elapsed = (now - lastUpdate) / 1_000_000_000.0;
                lastUpdate = now;

                if (simulationTime != null && !isFinished) {
                    if (isSlowMotionReplay && System.currentTimeMillis() > slowMotionEndTime) {
                        isSlowMotionReplay = false;
                        speedFactor = userSpeedSetting;
                        conflictFocusTrain = null;
                        addLog("Velocidade normalizada.", false);
                    }
                    checkDepartures();
                    if (!isPausedByConflict && !isSlowMotionReplay) checkForConflicts();
                    if (!isPausedByConflict) {
                        if (simulationTime.isAfter(maxSimulationTime)) {
                            isFinished = true;
                            addLog("Fim da Simula√ß√£o.", false);
                            showSuccessPanel();
                        } else {
                            simulationTime = simulationTime.plusSeconds((long) (elapsed * speedFactor));
                        }
                    }
                }
                updateCameraLogic();
                applyCameraSmoothing();
                updateFrame();
            }
        };
        timer.start();
    }

    private void checkDepartures() {
        for (VisualTrain vt : allTrains) {
            if (vt.movements.isEmpty()) continue;
            LocalTime ref = (vt.scheduledStart != null) ? vt.scheduledStart : vt.movements.get(0).start;
            long minToStart = ChronoUnit.MINUTES.between(simulationTime, ref);
            if (minToStart >= 0 && minToStart <= 10 && !vt.notifiedStart) {
                addLog("Partida: " + vt.train.getTrainId() + " (" + minToStart + " min)", false);
                vt.notifiedStart = true;
            }
        }
    }

    private void checkForConflicts() {
        for (VisualTrain vt : allTrains) {
            if (vt.hasInitialConflict && !simulationTime.isBefore(vt.scheduledStart) && simulationTime.isBefore(vt.movements.get(0).start) && !vt.isWaitNotified) {
                triggerConflictPause(vt, "Atraso (" + vt.initialDelayMinutes + " min) - Aguarda via livre");
                vt.isWaitNotified = true;
                break;
            }
            if (vt.isWaitingBetweenStations(simulationTime) && !vt.isWaitNotified) {
                triggerConflictPause(vt, "Cruzamento de linhas / Gest√£o Tr√°fego");
                vt.isWaitNotified = true;
                break;
            }
            if (!vt.hasInitialConflict && !vt.isWaitingBetweenStations(simulationTime)) vt.isWaitNotified = false;
        }
    }

    private void triggerConflictPause(VisualTrain t, String reason) {
        if (isPausedByConflict) return;
        isPausedByConflict = true;
        conflictFocusTrain = t;
        speedFactor = 0;
        Label desc = (Label) conflictPanel.lookup("#conflictDesc");
        if(desc != null) desc.setText("COMBOIO: " + t.train.getTrainId() + "\nLOCAL: " + t.getCurrentLocationName(simulationTime) + "\nMOTIVO: " + reason);
        addLog("‚ö† CONFLITO: " + t.train.getTrainId(), true);
        conflictPanel.setVisible(true);
        conflictPanel.toFront();
        autoCameraMode = false;
    }

    private void updateFrame() {
        GraphicsContext gc = canvas.getGraphicsContext2D();
        double w = getWidth(); double h = getHeight();
        gc.setFill(Color.web("#0b1120"));
        gc.fillRect(0, 0, w, h);
        gc.save();
        gc.translate(translateX, translateY);
        gc.scale(scale, scale);
        double viewScale = 1.0 / Math.max(0.2, scale);

        gc.setLineCap(javafx.scene.shape.StrokeLineCap.ROUND);
        for (VisualSegment s : segments) {
            double width = (s.isDouble ? 3.0 : 1.5) * viewScale;
            gc.setStroke(Color.rgb(255,255,255,0.1));
            gc.setLineWidth(width + 2);
            gc.strokeLine(s.p1.getX(), s.p1.getY(), s.p2.getX(), s.p2.getY());
            Color c = s.isDouble ? Color.web("#3b82f6") : Color.web("#f59e0b");
            if (isPausedByConflict) c = c.darker().desaturate();
            gc.setStroke(c);
            gc.setLineWidth(width);
            gc.strokeLine(s.p1.getX(), s.p1.getY(), s.p2.getX(), s.p2.getY());
        }

        Set<String> drawn = new HashSet<>();
        for (VisualSegment s : segments) {
            drawStation(gc, s.origName, s.p1, viewScale, drawn);
            drawStation(gc, s.destName, s.p2, viewScale, drawn);
        }
        for (VisualTrain t : allTrains) drawTrain(gc, t, viewScale);
        gc.restore();
        if (simulationTime != null) clockLabel.setText(simulationTime.format(DateTimeFormatter.ofPattern("HH:mm:ss")));
    }

    private void drawStation(GraphicsContext gc, String name, Point2D pos, double vs, Set<String> drawn) {
        if (drawn.contains(name)) return;
        drawn.add(name);
        double r = 2.5 * vs;
        gc.setFill(Color.WHITE);
        gc.fillOval(pos.getX() - r, pos.getY() - r, r*2, r*2);
        if (scale > 0.3) {
            gc.setFont(Font.font("Arial", 9 * vs));
            gc.setFill(Color.web("#94a3b8"));
            gc.fillText(name, pos.getX() + r + 4, pos.getY() + 3*vs);
        }
    }

    private void drawTrain(GraphicsContext gc, VisualTrain t, double vs) {
        Point2D p = t.getPosition(simulationTime);
        if (p == null) return;
        boolean waiting = t.isWaitingOrDelayed(simulationTime);
        boolean isFocus = (t == conflictFocusTrain);
        if (isPausedByConflict && !isFocus) gc.setGlobalAlpha(0.2);
        double r = (isFocus ? 10.0 : 6.0) * vs;
        Color c = waiting ? Color.web("#ef4444") : Color.web("#10b981");
        if (waiting || isFocus) {
            double pulse = r * (1.2 + 0.2 * Math.sin(System.currentTimeMillis() / 100.0));
            gc.setStroke(Color.web("#ef4444", 0.7));
            gc.setLineWidth(1.5 * vs);
            gc.strokeOval(p.getX() - pulse, p.getY() - pulse, pulse*2, pulse*2);
        }
        gc.setFill(c);
        gc.setEffect(new DropShadow(5 * vs, c));
        gc.fillOval(p.getX() - r, p.getY() - r, r*2, r*2);
        gc.setEffect(null);
        if (scale > 0.4 || isFocus || waiting) {
            gc.setFill(Color.WHITE);
            gc.setFont(Font.font("Arial", FontWeight.BOLD, 9 * vs));
            gc.fillText(t.train.getTrainId(), p.getX() + r + 2, p.getY() - r);
        }
        gc.setGlobalAlpha(1.0);
    }

    private void updateCameraLogic() {
        if (conflictFocusTrain != null && isPausedByConflict) {
            Point2D p = conflictFocusTrain.getPosition(simulationTime);
            if(p != null) {
                targetScale = 2.0;
                targetTranslateX = (getWidth()/2.0) - (p.getX() * targetScale);
                targetTranslateY = (getHeight()/2.0) - (p.getY() * targetScale);
                applyCameraSmoothing();
            }
            return;
        }
        if (!autoCameraMode) return;
        double sumX = 0, sumY = 0;
        int count = 0;
        double minX = Double.MAX_VALUE, maxX = -Double.MAX_VALUE;
        double minY = Double.MAX_VALUE, maxY = -Double.MAX_VALUE;
        if (simulationTime != null) {
            for (VisualTrain vt : allTrains) {
                if (vt.isActive(simulationTime) || vt.hasInitialConflict) {
                    Point2D p = vt.getPosition(simulationTime);
                    if (p != null) {
                        sumX += p.getX(); sumY += p.getY();
                        minX = Math.min(minX, p.getX()); maxX = Math.max(maxX, p.getX());
                        minY = Math.min(minY, p.getY()); maxY = Math.max(maxY, p.getY());
                        count++;
                    }
                }
            }
        }
        if (count == 0) return;
        double centerX = sumX / count;
        double centerY = sumY / count;
        if (count == 1) {
            targetScale = 1.5;
        } else {
            double width = Math.max(300, maxX - minX);
            double height = Math.max(300, maxY - minY);
            double scaleX = (getWidth() - 150) / width;
            double scaleY = (getHeight() - 150) / height;
            targetScale = Math.max(0.4, Math.min(Math.min(scaleX, scaleY), 1.5));
        }
        targetTranslateX = (getWidth() / 2.0) - (centerX * targetScale);
        targetTranslateY = (getHeight() / 2.0) - (centerY * targetScale);
        applyCameraSmoothing();
    }

    private void applyCameraSmoothing() {
        double smooth = (isPausedByConflict) ? 0.1 : 0.05;
        scale += (targetScale - scale) * smooth;
        translateX += (targetTranslateX - translateX) * smooth;
        translateY += (targetTranslateY - translateY) * smooth;
    }

    private void setupInteraction() {
        canvasPane.setOnScroll(e -> {
            if (!isPausedByConflict) { autoCameraMode = false; btnAutoCam.setSelected(false); targetScale *= (e.getDeltaY() > 0 ? 1.1 : 0.9); }
        });
        canvasPane.setOnMousePressed(e -> { lastMouseX = e.getX(); lastMouseY = e.getY(); });
        canvasPane.setOnMouseDragged(e -> {
            if (!isPausedByConflict) { autoCameraMode = false; btnAutoCam.setSelected(false); targetTranslateX += (e.getX() - lastMouseX); targetTranslateY += (e.getY() - lastMouseY); lastMouseX = e.getX(); lastMouseY = e.getY(); updateFrame(); }
        });
    }

    public void setSpeedFactor(double f) { userSpeedSetting = f; if(!isSlowMotionReplay && !isPausedByConflict) speedFactor = f; }
    public void stopAnimation() { if(timer != null) timer.stop(); }
    private void manualZoom(double f) { autoCameraMode = false; btnAutoCam.setSelected(false); targetScale *= f; }

    private static class ConflictInfo {
        String station; int delayMinutes;
        ConflictInfo(String s, int d) { this.station = s; this.delayMinutes = d; }
    }
    private static class VisualSegment {
        String origName, destName; Point2D p1, p2; boolean isDouble;
        VisualSegment(String s, String e, Point2D p1, Point2D p2, boolean d) { this.origName = s; this.destName = e; this.p1 = p1; this.p2 = p2; this.isDouble = d; }
        boolean matches(String s, String e) { return (origName.equalsIgnoreCase(s) && destName.equalsIgnoreCase(e)) || (origName.equalsIgnoreCase(e) && destName.equalsIgnoreCase(s)); }
    }
    private static class VisualTrain {
        Train train; List<VisualMovement> movements = new ArrayList<>();
        boolean hasInitialConflict = false; int initialDelayMinutes = 0; LocalTime scheduledStart = null;
        boolean notifiedStart = false; boolean isWaitNotified = false;
        VisualTrain(Train t) { this.train = t; }
        void addMovement(LocalTime s, LocalTime e, Point2D p1, Point2D p2, String st1, String st2) {
            movements.add(new VisualMovement(s, e, p1, p2, st1, st2));
            movements.sort(Comparator.comparing(m -> m.start));
        }
        boolean isWaitingOrDelayed(LocalTime t) {
            if (t == null || movements.isEmpty()) return false;
            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) return true;
            return isWaitingBetweenStations(t);
        }
        boolean isWaitingBetweenStations(LocalTime t) {
            for (int i = 0; i < movements.size() - 1; i++) if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i+1).start)) return true;
            return false;
        }
        boolean isActive(LocalTime t) {
            if (t == null || movements.isEmpty()) return false;
            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) return true;
            for (VisualMovement m : movements) if (!t.isBefore(m.start) && !t.isAfter(m.end)) return true;
            return false;
        }
        Point2D getPosition(LocalTime t) {
            if (t == null || movements.isEmpty()) return null;
            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) {
                if (java.time.Duration.between(t, movements.get(0).start).toMinutes() <= 30) return movements.get(0).p1;
                return null;
            }
            for (VisualMovement m : movements) {
                if (!t.isBefore(m.start) && !t.isAfter(m.end)) {
                    long totalSeconds = java.time.Duration.between(m.start, m.end).getSeconds();
                    long currentSeconds = java.time.Duration.between(m.start, t).getSeconds();
                    double r = (totalSeconds <= 0) ? 1.0 : (double) currentSeconds / totalSeconds;
                    return new Point2D(m.p1.getX() + (m.p2.getX() - m.p1.getX()) * r, m.p1.getY() + (m.p2.getY() - m.p1.getY()) * r);
                }
            }
            for (int i = 0; i < movements.size() - 1; i++) if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i + 1).start)) return movements.get(i).p2;
            if (!movements.isEmpty() && t.isBefore(movements.get(0).start)) {
                LocalTime ref = hasInitialConflict ? scheduledStart : movements.get(0).start;
                if (java.time.Duration.between(t, ref).toMinutes() <= 15) return movements.get(0).p1;
            }
            return null;
        }
        String getCurrentLocationName(LocalTime t) {
            if (t == null || movements.isEmpty()) return "?";
            if (hasInitialConflict && t.isBefore(movements.get(0).start)) return movements.get(0).fromStation;
            for (int i = 0; i < movements.size() - 1; i++) if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i+1).start)) return movements.get(i).destStation;
            return "Em linha";
        }
    }
    private static class VisualMovement {
        LocalTime start, end; Point2D p1, p2; String fromStation, destStation;
        VisualMovement(LocalTime s, LocalTime e, Point2D p1, Point2D p2, String st1, String st2) { this.start = s; this.end = e; this.p1 = p1; this.p2 = p2; this.fromStation = st1; this.destStation = st2; }
    }
}