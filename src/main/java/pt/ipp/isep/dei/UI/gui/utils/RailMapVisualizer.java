package pt.ipp.isep.dei.UI.gui.utils;

import javafx.animation.AnimationTimer;
import javafx.animation.FadeTransition;
import javafx.geometry.Insets;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.ToggleButton;
import javafx.scene.effect.DropShadow;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.util.Duration;
import pt.ipp.isep.dei.domain.Train;

import java.text.Normalizer;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.regex.Pattern;

public class RailMapVisualizer extends StackPane {

    // --- COMPONENTES UI ---
    private final Canvas canvas;
    private final Pane canvasPane;
    private final VBox notificationPanel;

    // Variáveis não-final para permitir inicialização no método auxiliar
    private VBox notificationContent;
    private Button notificationHeader;

    private final VBox conflictPanel;

    // --- DADOS ---
    private final Map<String, Point2D> stationCoordinates = new HashMap<>();
    private final Map<String, Point2D> autoGeneratedCoordinates = new HashMap<>();
    private final List<VisualSegment> segments = new ArrayList<>();
    private final List<VisualTrain> allTrains = new ArrayList<>();
    private final Map<String, ConflictInfo> conflictRegistry = new HashMap<>();

    // --- CÂMARA ---
    private double scale = 0.6; // Começar com um pouco mais de zoom
    private double translateX = 0, translateY = 0;
    private double targetScale = 0.6;
    private double targetTranslateX = 0, targetTranslateY = 0;
    private boolean autoCameraMode = true;
    private double lastMouseX, lastMouseY;

    // --- SIMULAÇÃO ---
    private LocalTime simulationTime;
    private LocalTime maxSimulationTime;
    private double speedFactor = 50.0;
    private double userSpeedSetting = 50.0;
    private AnimationTimer timer;
    private boolean isFinished = false;

    // --- ESTADO CRÍTICO ---
    private boolean isPausedByConflict = false;
    private boolean isSlowMotionReplay = false;
    private VisualTrain conflictFocusTrain = null;
    private long slowMotionEndTime = 0;

    // --- CONTROLOS ---
    private final Button btnZoomIn, btnZoomOut;
    private final ToggleButton btnAutoCam;
    private final Label clockLabel;

    public RailMapVisualizer() {
        this.setStyle("-fx-background-color: #0f172a;"); // Fundo Slate Dark

        // 1. Layer Mapa
        this.canvasPane = new Pane();
        this.canvas = new Canvas(1000, 800); // Canvas maior internamente
        this.canvasPane.getChildren().add(canvas);
        canvas.widthProperty().bind(this.widthProperty());
        canvas.heightProperty().bind(this.heightProperty());

        setupRealisticMapCoordinates();

        // 2. Layer HUD (Acordeão)
        this.notificationPanel = createNotificationPanel();

        // 3. Layer Controlos
        this.btnZoomIn = createGlassButton("+");
        this.btnZoomIn.setOnAction(e -> manualZoom(1.2));
        this.btnZoomOut = createGlassButton("-");
        this.btnZoomOut.setOnAction(e -> manualZoom(0.8));

        this.btnAutoCam = new ToggleButton("AUTO CAM");
        this.btnAutoCam.setSelected(true);
        this.btnAutoCam.setStyle("-fx-background-color: rgba(16, 185, 129, 0.2); -fx-text-fill: #10b981; -fx-font-weight: bold; -fx-border-color: rgba(16, 185, 129, 0.4); -fx-border-radius: 5;");
        this.btnAutoCam.selectedProperty().addListener((obs, old, isSelected) -> autoCameraMode = isSelected);

        this.clockLabel = new Label("00:00:00");
        this.clockLabel.setStyle("-fx-text-fill: white; -fx-font-family: 'Monospaced'; -fx-font-size: 28px; -fx-font-weight: bold; -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.8), 5, 0, 0, 1);");

        HBox controlsBox = new HBox(10, btnZoomIn, btnZoomOut, btnAutoCam, clockLabel);
        controlsBox.setAlignment(Pos.TOP_RIGHT);
        controlsBox.setPadding(new Insets(20));
        controlsBox.setPickOnBounds(false);

        // 4. Layer Modal
        this.conflictPanel = createConflictPanel();

        this.getChildren().addAll(canvasPane, notificationPanel, controlsBox, conflictPanel);
        StackPane.setAlignment(controlsBox, Pos.TOP_RIGHT);
        StackPane.setAlignment(notificationPanel, Pos.TOP_LEFT);
        StackPane.setAlignment(conflictPanel, Pos.CENTER);

        setupInteraction();
    }

    // --- UI DE NOTIFICAÇÕES (CORRIGIDA) ---
    private VBox createNotificationPanel() {
        VBox container = new VBox(0);
        container.setMaxHeight(350);
        container.setMaxWidth(320);
        container.setPadding(new Insets(20));
        container.setPickOnBounds(false);

        // Header
        notificationHeader = new Button("LOG DE TRÁFEGO ▼");
        notificationHeader.setMaxWidth(Double.MAX_VALUE);
        notificationHeader.setStyle("-fx-background-color: #1e293b; -fx-text-fill: white; -fx-font-weight: bold; -fx-background-radius: 8 8 0 0; -fx-border-color: #475569; -fx-border-width: 1 1 0 1; -fx-cursor: hand; -fx-padding: 8;");

        // Conteúdo
        notificationContent = new VBox(8);
        notificationContent.setPadding(new Insets(10));
        notificationContent.setStyle("-fx-background-color: rgba(15, 23, 42, 0.95);"); // Fundo opaco

        ScrollPane scroll = new ScrollPane(notificationContent);
        scroll.setFitToWidth(true);
        scroll.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        scroll.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);
        scroll.setStyle("-fx-background: transparent; -fx-background-color: transparent;");
        scroll.setMaxHeight(250);

        // Impedir que o scroll do log faça zoom no mapa
        scroll.setOnScroll(e -> e.consume());

        // Wrapper do conteúdo
        VBox contentWrapper = new VBox(scroll);
        contentWrapper.setStyle("-fx-background-color: rgba(15, 23, 42, 0.95); -fx-background-radius: 0 0 8 8; -fx-border-color: #475569; -fx-border-width: 0 1 1 1;");
        contentWrapper.setEffect(new DropShadow(10, Color.BLACK));

        // Ação do Botão
        notificationHeader.setOnAction(e -> {
            boolean isVisible = contentWrapper.isVisible();
            contentWrapper.setVisible(!isVisible);
            contentWrapper.setManaged(!isVisible);
            notificationHeader.setText(isVisible ? "LOG DE TRÁFEGO ▶" : "LOG DE TRÁFEGO ▼");

            // Ajusta o estilo se estiver fechado para arredondar em baixo
            if (isVisible) {
                notificationHeader.setStyle(notificationHeader.getStyle().replace("-fx-background-radius: 8 8 0 0;", "-fx-background-radius: 8;"));
            } else {
                notificationHeader.setStyle(notificationHeader.getStyle().replace("-fx-background-radius: 8;", "-fx-background-radius: 8 8 0 0;"));
            }
        });

        container.getChildren().addAll(notificationHeader, contentWrapper);
        return container;
    }

    public void addLog(String msg, boolean isCritical) {
        Label lbl = new Label((isCritical ? "⚠ " : "➤ ") + msg);
        lbl.setWrapText(true);
        lbl.setMaxWidth(270);
        lbl.setFont(Font.font("Segoe UI", FontWeight.NORMAL, 12));

        if (isCritical) {
            lbl.setStyle("-fx-text-fill: #ff6b6b; -fx-font-weight: bold; -fx-background-color: rgba(255,0,0,0.1); -fx-padding: 3; -fx-background-radius: 3;");
        } else {
            lbl.setStyle("-fx-text-fill: #cbd5e1; -fx-padding: 2;");
        }

        notificationContent.getChildren().add(0, lbl);

        if (notificationContent.getChildren().size() > 40) {
            notificationContent.getChildren().remove(40, notificationContent.getChildren().size());
        }
    }

    // --- COORDENADAS REAIS MAPA PORTUGAL (Escalado para 800x600) ---
    private void setupRealisticMapCoordinates() {
        // Baseado na geografia real mas compactado para caber no ecrã.
        // X aumenta para a direita (Este), Y aumenta para baixo (Sul)

        // --- LINHA DO MINHO (Norte Litoral) ---
        addStation("Valenca", 250, 50);
        addStation("Sao Pedro da Torre", 250, 80);
        addStation("Vila Nova de Cerveira", 240, 110);
        addStation("Caminha", 230, 140);
        addStation("Ancora Praia", 230, 170);
        addStation("Afife", 230, 200);
        addStation("Viana do Castelo", 230, 230);
        addStation("Barcelos", 260, 280);

        // --- RAMAL DE BRAGA & NINE ---
        addStation("Nine", 300, 310); // Ponto de encontro
        addStation("Tadim", 340, 300);
        addStation("Braga", 380, 290); // Braga é a Este de Nine

        // --- DESCIDA PARA O PORTO ---
        addStation("Famalicao", 300, 340);
        addStation("Trofa", 300, 370);

        // Guimarães (Nordeste do Porto)
        addStation("Santo Tirso", 350, 360);
        addStation("Guimaraes", 400, 350);

        // --- GRANDE PORTO (Centro do Canvas, ligeiramente à esquerda) ---
        addStation("Ermesinde", 320, 400); // Hub crítico
        addStation("Rio Tinto", 310, 420);
        addStation("Contumil", 300, 435);
        addStation("Porto Campanha", 280, 450); // O CORAÇÃO DO SISTEMA
        addStation("Porto Sao Bento", 250, 455); // Mais a Oeste

        // --- LINHA DO DOURO (Estende-se para Este/Direita) ---
        addStation("Valongo", 360, 410);
        addStation("Paredes", 400, 415);
        addStation("Penafiel", 430, 420);
        addStation("Caide", 480, 425);
        addStation("Marco de Canaveses", 530, 430);
        addStation("Regua", 650, 450);
        addStation("Pinhao", 720, 460);
        addStation("Pocinho", 850, 470); // Extremo Este

        // --- LINHA DO NORTE (Desce para Sul) ---
        addStation("Vila Nova de Gaia", 280, 480); // Logo abaixo do Douro
        addStation("Granja", 280, 510);
        addStation("Espinho", 270, 530);
        addStation("Ovar", 260, 570);
        addStation("Aveiro", 250, 630);
        addStation("Coimbra B", 240, 750); // Bem mais a sul
        addStation("Entroncamento", 200, 900); // Nó ferroviário
        addStation("Lisboa Oriente", 150, 1100);
        addStation("Lisboa Santa Apolonia", 140, 1150);
    }

    // --- RESTO DO CÓDIGO (Lógica Visual e Simulação) ---

    private VBox createConflictPanel() {
        VBox panel = new VBox(15);
        panel.setAlignment(Pos.CENTER);
        panel.setMaxSize(480, 300);
        panel.setStyle("-fx-background-color: rgba(15, 23, 42, 0.98); -fx-background-radius: 15; -fx-border-color: #ef4444; -fx-border-width: 3; -fx-effect: dropshadow(three-pass-box, rgba(239, 68, 68, 0.6), 80, 0, 0, 0);");

        Label icon = new Label("⚠ COLISÃO EVITADA");
        icon.setStyle("-fx-text-fill: #ef4444; -fx-font-size: 26px; -fx-font-weight: bold;");

        Label desc = new Label("Sistemas de segurança ativados.");
        desc.setId("conflictDesc");
        desc.setStyle("-fx-text-fill: #cbd5e1; -fx-font-size: 16px; -fx-text-alignment: center;");
        desc.setWrapText(true);

        Button btn = new Button("VISUALIZAR AÇÃO (Retomar)");
        btn.setStyle("-fx-background-color: white; -fx-text-fill: #0f172a; -fx-font-weight: bold; -fx-padding: 12 25; -fx-background-radius: 20; -fx-cursor: hand; -fx-font-size: 14px;");

        btn.setOnAction(e -> {
            panel.setVisible(false);
            isPausedByConflict = false;
            // 3 Segundos de câmara lenta
            isSlowMotionReplay = true;
            speedFactor = 1.0;
            slowMotionEndTime = System.currentTimeMillis() + 3000;
            addLog("▶ Retomando tráfego...", false);
        });

        panel.getChildren().addAll(icon, desc, btn);
        panel.setVisible(false);
        return panel;
    }

    // [MÉTODOS HELPER IGUAIS: normalize, addStation, getCoordinates]
    private String normalize(String s) {
        if (s == null) return "";
        String temp = Normalizer.normalize(s, Normalizer.Form.NFD);
        Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+");
        return pattern.matcher(temp).replaceAll("").toLowerCase().trim()
                .replace(" - ", " ").replace("-", " ")
                .replace("ç", "c").replace("ã", "a").replace("õ", "o").replace("é", "e");
    }

    private void addStation(String name, double x, double y) {
        stationCoordinates.put(normalize(name), new Point2D(x, y));
    }

    private Point2D getCoordinates(String name) {
        String key = normalize(name);
        if (stationCoordinates.containsKey(key)) return stationCoordinates.get(key);
        for (String k : stationCoordinates.keySet()) {
            if (k.contains(key) || key.contains(k)) return stationCoordinates.get(k);
        }
        if (!autoGeneratedCoordinates.containsKey(key)) {
            autoGeneratedCoordinates.put(key, new Point2D(1000, 500 + autoGeneratedCoordinates.size() * 50));
        }
        return autoGeneratedCoordinates.get(key);
    }

    // [LÓGICA DE DADOS - IGUAL]
    public void loadSchedule(Map<Train, List<String>> trainSchedules, LocalTime time) {
        segments.clear();
        allTrains.clear();
        conflictRegistry.clear();
        notificationContent.getChildren().clear();
        conflictPanel.setVisible(false);
        isFinished = false;

        LocalTime minT = LocalTime.MAX;
        LocalTime maxT = LocalTime.MIN;

        for (List<String> logs : trainSchedules.values()) {
            for (String line : logs) {
                if (line.startsWith("!!!CONFLICT")) {
                    String[] parts = line.split("\\|");
                    if (parts.length >= 4) {
                        conflictRegistry.put(parts[1], new ConflictInfo(parts[2], Integer.parseInt(parts[3])));
                    }
                }
            }
        }

        for (Map.Entry<Train, List<String>> entry : trainSchedules.entrySet()) {
            Train train = entry.getKey();
            VisualTrain vt = new VisualTrain(train);
            boolean hasData = false;

            for (String logLine : entry.getValue()) {
                if (logLine.startsWith("!!!")) continue;
                String[] parts = logLine.split("\\|");
                if (parts.length < 7) continue;

                try {
                    String startSt = parts[1].trim();
                    String endSt = parts[2].trim();
                    if (parts[5].trim().equals("N/A") || parts[6].trim().equals("N/A")) continue;

                    LocalTime in = LocalTime.parse(parts[5].trim());
                    LocalTime out = LocalTime.parse(parts[6].trim());

                    if (in.isBefore(minT)) minT = in;
                    if (out.isAfter(maxT)) maxT = out;

                    Point2D p1 = getCoordinates(startSt);
                    Point2D p2 = getCoordinates(endSt);

                    if (segments.stream().noneMatch(s -> s.matches(startSt, endSt))) {
                        boolean isDouble = parts[3].toLowerCase().contains("double");
                        segments.add(new VisualSegment(startSt, endSt, p1, p2, isDouble));
                    }
                    vt.addMovement(in, out, p1, p2, startSt, endSt);
                    hasData = true;
                } catch (Exception e) {}
            }

            if (hasData) {
                ConflictInfo c = conflictRegistry.get(train.getTrainId());
                if (c != null && !vt.movements.isEmpty()) {
                    vt.initialDelayMinutes = c.delayMinutes;
                    vt.hasInitialConflict = true;
                    vt.scheduledStart = vt.movements.get(0).start.minusMinutes(c.delayMinutes);
                }
                allTrains.add(vt);
            }
        }

        this.simulationTime = (minT == LocalTime.MAX) ? LocalTime.of(8, 0) : minT.minusMinutes(30);
        this.maxSimulationTime = maxT.plusMinutes(30);

        autoCameraMode = true;
        btnAutoCam.setSelected(true);
        scale = 0.6; translateX = 0; translateY = 0;
        updateFrame();
        addLog("Rede carregada.", false);
    }

    // [SIMULAÇÃO LOOP - IGUAL]
    public void startAnimation() {
        if (timer != null) timer.stop();
        if (allTrains.isEmpty()) return;

        timer = new AnimationTimer() {
            private long lastUpdate = 0;
            @Override
            public void handle(long now) {
                if (lastUpdate == 0) { lastUpdate = now; return; }
                double elapsed = (now - lastUpdate) / 1_000_000_000.0;
                lastUpdate = now;

                if (simulationTime != null && !isFinished) {
                    if (isSlowMotionReplay && System.currentTimeMillis() > slowMotionEndTime) {
                        isSlowMotionReplay = false;
                        speedFactor = userSpeedSetting;
                        conflictFocusTrain = null;
                        addLog("Velocidade normalizada.", false);
                    }

                    checkDepartures();

                    if (!isPausedByConflict && !isSlowMotionReplay) {
                        checkForConflicts();
                    }

                    if (!isPausedByConflict) {
                        if (simulationTime.isAfter(maxSimulationTime)) {
                            isFinished = true;
                            addLog("Fim da Simulação.", false);
                        } else {
                            simulationTime = simulationTime.plusSeconds((long) (elapsed * speedFactor));
                        }
                    }
                }
                updateCameraLogic();
                applyCameraSmoothing();
                updateFrame();
            }
        };
        timer.start();
    }

    private void checkDepartures() {
        for (VisualTrain vt : allTrains) {
            if (vt.movements.isEmpty()) continue;
            LocalTime ref = (vt.scheduledStart != null) ? vt.scheduledStart : vt.movements.get(0).start;
            long minToStart = ChronoUnit.MINUTES.between(simulationTime, ref);

            if (minToStart >= 0 && minToStart <= 10 && !vt.notifiedStart) {
                addLog("Partida: " + vt.train.getTrainId() + " (" + minToStart + " min)", false);
                vt.notifiedStart = true;
            }
        }
    }

    private void checkForConflicts() {
        for (VisualTrain vt : allTrains) {
            if (vt.hasInitialConflict &&
                    !simulationTime.isBefore(vt.scheduledStart) &&
                    simulationTime.isBefore(vt.movements.get(0).start) &&
                    !vt.isWaitNotified) {

                triggerConflictPause(vt, "Atraso (" + vt.initialDelayMinutes + " min) - Aguarda via livre");
                vt.isWaitNotified = true;
                break;
            }
            if (vt.isWaitingBetweenStations(simulationTime) && !vt.isWaitNotified) {
                triggerConflictPause(vt, "Cruzamento de linhas / Gestão Tráfego");
                vt.isWaitNotified = true;
                break;
            }
            if (!vt.hasInitialConflict && !vt.isWaitingBetweenStations(simulationTime)) {
                vt.isWaitNotified = false;
            }
        }
    }

    private void triggerConflictPause(VisualTrain t, String reason) {
        if (isPausedByConflict) return;
        isPausedByConflict = true;
        conflictFocusTrain = t;
        speedFactor = 0;

        Label desc = (Label) conflictPanel.lookup("#conflictDesc");
        if(desc != null) {
            desc.setText("COMBOIO: " + t.train.getTrainId() + "\nLOCAL: " + t.getCurrentLocationName(simulationTime) +
                    "\nMOTIVO: " + reason);
        }
        addLog("⚠ CONFLITO: " + t.train.getTrainId(), true);
        conflictPanel.setVisible(true);
        conflictPanel.toFront();
        autoCameraMode = false;
    }

    // [VISUALIZAÇÃO - UPDATE FRAME]
    private void updateFrame() {
        GraphicsContext gc = canvas.getGraphicsContext2D();
        double w = getWidth(); double h = getHeight();
        gc.setFill(Color.web("#0f172a"));
        gc.fillRect(0, 0, w, h);
        gc.save();
        gc.translate(translateX, translateY);
        gc.scale(scale, scale);
        double viewScale = 1.0 / Math.max(0.2, scale);

        gc.setLineCap(javafx.scene.shape.StrokeLineCap.ROUND);

        for (VisualSegment s : segments) {
            double width = (s.isDouble ? 3.0 : 1.5) * viewScale;
            gc.setStroke(Color.rgb(255,255,255,0.1));
            gc.setLineWidth(width + 2);
            gc.strokeLine(s.p1.getX(), s.p1.getY(), s.p2.getX(), s.p2.getY());
            Color c = s.isDouble ? Color.web("#3b82f6") : Color.web("#f59e0b");
            if (isPausedByConflict) c = c.darker().desaturate();
            gc.setStroke(c);
            gc.setLineWidth(width);
            gc.strokeLine(s.p1.getX(), s.p1.getY(), s.p2.getX(), s.p2.getY());
        }

        Set<String> drawn = new HashSet<>();
        for (VisualSegment s : segments) {
            drawStation(gc, s.origName, s.p1, viewScale, drawn);
            drawStation(gc, s.destName, s.p2, viewScale, drawn);
        }

        for (VisualTrain t : allTrains) drawTrain(gc, t, viewScale);
        gc.restore();

        if (simulationTime != null) clockLabel.setText(simulationTime.format(DateTimeFormatter.ofPattern("HH:mm:ss")));
    }

    private void drawStation(GraphicsContext gc, String name, Point2D pos, double vs, Set<String> drawn) {
        if (drawn.contains(name)) return;
        drawn.add(name);
        double r = 2.5 * vs;
        gc.setFill(Color.WHITE);
        gc.fillOval(pos.getX() - r, pos.getY() - r, r*2, r*2);

        if (scale > 0.6) {
            gc.setFont(Font.font("Arial", 9 * vs));
            gc.setFill(Color.web("#94a3b8"));
            gc.fillText(name, pos.getX() + r + 4, pos.getY() + 3*vs);
        }
    }

    private void drawTrain(GraphicsContext gc, VisualTrain t, double vs) {
        Point2D p = t.getPosition(simulationTime);
        if (p == null) return;

        boolean waiting = t.isWaitingOrDelayed(simulationTime);
        boolean isFocus = (t == conflictFocusTrain);

        if (isPausedByConflict && !isFocus) gc.setGlobalAlpha(0.2);

        double r = (isFocus ? 10.0 : 6.0) * vs;
        Color c = waiting ? Color.web("#ef4444") : Color.web("#10b981");

        if (waiting || isFocus) {
            double pulse = r * (1.2 + 0.2 * Math.sin(System.currentTimeMillis() / 100.0));
            gc.setStroke(Color.web("#ef4444", 0.7));
            gc.setLineWidth(1.5 * vs);
            gc.strokeOval(p.getX() - pulse, p.getY() - pulse, pulse*2, pulse*2);
        }

        gc.setFill(c);
        gc.setEffect(new DropShadow(5 * vs, c));
        gc.fillOval(p.getX() - r, p.getY() - r, r*2, r*2);
        gc.setEffect(null);

        if (scale > 0.6 || isFocus || waiting) {
            gc.setFill(Color.WHITE);
            gc.setFont(Font.font("Arial", FontWeight.BOLD, 9 * vs));
            gc.fillText(t.train.getTrainId(), p.getX() + r + 2, p.getY() - r);
        }
        gc.setGlobalAlpha(1.0);
    }

    // [CÂMARA AUTOMÁTICA INTELIGENTE]
    private void updateCameraLogic() {
        if (conflictFocusTrain != null && isPausedByConflict) {
            Point2D p = conflictFocusTrain.getPosition(simulationTime);
            if(p != null) {
                targetScale = 2.0;
                targetTranslateX = (getWidth()/2.0) - (p.getX() * targetScale);
                targetTranslateY = (getHeight()/2.0) - (p.getY() * targetScale);
                applyCameraSmoothing();
            }
            return;
        }

        if (!autoCameraMode) return;

        double sumX = 0, sumY = 0;
        int count = 0;
        double minX = Double.MAX_VALUE, maxX = -Double.MAX_VALUE;
        double minY = Double.MAX_VALUE, maxY = -Double.MAX_VALUE;

        if (simulationTime != null) {
            for (VisualTrain vt : allTrains) {
                if (vt.isActive(simulationTime) || vt.hasInitialConflict) {
                    Point2D p = vt.getPosition(simulationTime);
                    if (p != null) {
                        sumX += p.getX(); sumY += p.getY();
                        minX = Math.min(minX, p.getX()); maxX = Math.max(maxX, p.getX());
                        minY = Math.min(minY, p.getY()); maxY = Math.max(maxY, p.getY());
                        count++;
                    }
                }
            }
        }

        if (count == 0) return;

        double centerX = sumX / count;
        double centerY = sumY / count;

        // Se houver só um comboio, foca nele
        if (count == 1) {
            targetScale = 1.5;
        } else {
            // Se houver vários, tenta enquadrar todos com margem
            double width = Math.max(300, maxX - minX);
            double height = Math.max(300, maxY - minY);
            double scaleX = (getWidth() - 150) / width;
            double scaleY = (getHeight() - 150) / height;
            targetScale = Math.max(0.5, Math.min(Math.min(scaleX, scaleY), 1.5));
        }

        targetTranslateX = (getWidth() / 2.0) - (centerX * targetScale);
        targetTranslateY = (getHeight() / 2.0) - (centerY * targetScale);

        applyCameraSmoothing();
    }

    private void applyCameraSmoothing() {
        double smooth = (isPausedByConflict) ? 0.1 : 0.05;
        scale += (targetScale - scale) * smooth;
        translateX += (targetTranslateX - translateX) * smooth;
        translateY += (targetTranslateY - translateY) * smooth;
    }

    private void setupInteraction() {
        canvasPane.setOnScroll(e -> {
            if (!isPausedByConflict) { autoCameraMode = false; btnAutoCam.setSelected(false); targetScale *= (e.getDeltaY() > 0 ? 1.1 : 0.9); }
        });
        canvasPane.setOnMousePressed(e -> { lastMouseX = e.getX(); lastMouseY = e.getY(); });
        canvasPane.setOnMouseDragged(e -> {
            if (!isPausedByConflict) { autoCameraMode = false; btnAutoCam.setSelected(false); targetTranslateX += (e.getX() - lastMouseX); targetTranslateY += (e.getY() - lastMouseY); lastMouseX = e.getX(); lastMouseY = e.getY(); updateFrame(); }
        });
    }

    private Button createGlassButton(String text) {
        Button btn = new Button(text);
        btn.setStyle("-fx-background-color: rgba(255, 255, 255, 0.1); -fx-text-fill: white; -fx-font-weight: bold; -fx-min-width: 30px; -fx-background-radius: 5; -fx-border-color: rgba(255,255,255,0.2);");
        return btn;
    }

    public void setSpeedFactor(double f) { userSpeedSetting = f; if(!isSlowMotionReplay && !isPausedByConflict) speedFactor = f; }
    public void stopAnimation() { if(timer != null) timer.stop(); }
    private void manualZoom(double f) { autoCameraMode = false; btnAutoCam.setSelected(false); targetScale *= f; }

    // --- CLASSES INTERNAS ---
    private static class ConflictInfo {
        String station; int delayMinutes;
        ConflictInfo(String s, int d) { this.station = s; this.delayMinutes = d; }
    }
    private static class VisualSegment {
        String origName, destName; Point2D p1, p2; boolean isDouble;
        VisualSegment(String s, String e, Point2D p1, Point2D p2, boolean d) { this.origName = s; this.destName = e; this.p1 = p1; this.p2 = p2; this.isDouble = d; }
        boolean matches(String s, String e) { return (origName.equalsIgnoreCase(s) && destName.equalsIgnoreCase(e)) || (origName.equalsIgnoreCase(e) && destName.equalsIgnoreCase(s)); }
    }
    private static class VisualTrain {
        Train train; List<VisualMovement> movements = new ArrayList<>();
        boolean hasInitialConflict = false; int initialDelayMinutes = 0; LocalTime scheduledStart = null;
        boolean notifiedStart = false; boolean isWaitNotified = false;
        VisualTrain(Train t) { this.train = t; }
        void addMovement(LocalTime s, LocalTime e, Point2D p1, Point2D p2, String st1, String st2) {
            movements.add(new VisualMovement(s, e, p1, p2, st1, st2));
            movements.sort(Comparator.comparing(m -> m.start));
        }
        boolean isWaitingOrDelayed(LocalTime t) {
            if (t == null || movements.isEmpty()) return false;
            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) return true;
            return isWaitingBetweenStations(t);
        }
        boolean isWaitingBetweenStations(LocalTime t) {
            for (int i = 0; i < movements.size() - 1; i++) {
                if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i+1).start)) return true;
            }
            return false;
        }
        boolean isActive(LocalTime t) {
            if (t == null || movements.isEmpty()) return false;
            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) return true;
            for (VisualMovement m : movements) if (!t.isBefore(m.start) && !t.isAfter(m.end)) return true;
            return false;
        }
        Point2D getPosition(LocalTime t) {
            if (t == null || movements.isEmpty()) return null;
            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) {
                if (java.time.Duration.between(t, movements.get(0).start).toMinutes() <= 30) return movements.get(0).p1;
                return null;
            }
            for (VisualMovement m : movements) {
                if (!t.isBefore(m.start) && !t.isAfter(m.end)) {
                    long totalSeconds = java.time.Duration.between(m.start, m.end).getSeconds();
                    long currentSeconds = java.time.Duration.between(m.start, t).getSeconds();
                    double r = (totalSeconds <= 0) ? 1.0 : (double) currentSeconds / totalSeconds;
                    return new Point2D(m.p1.getX() + (m.p2.getX() - m.p1.getX()) * r, m.p1.getY() + (m.p2.getY() - m.p1.getY()) * r);
                }
            }
            for (int i = 0; i < movements.size() - 1; i++) {
                if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i + 1).start)) return movements.get(i).p2;
            }
            if (!movements.isEmpty() && t.isBefore(movements.get(0).start)) {
                LocalTime ref = hasInitialConflict ? scheduledStart : movements.get(0).start;
                if (java.time.Duration.between(t, ref).toMinutes() <= 15) return movements.get(0).p1;
            }
            return null;
        }
        String getCurrentLocationName(LocalTime t) {
            if (t == null || movements.isEmpty()) return "?";
            if (hasInitialConflict && t.isBefore(movements.get(0).start)) return movements.get(0).fromStation;
            for (int i = 0; i < movements.size() - 1; i++) {
                if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i+1).start)) return movements.get(i).destStation;
            }
            return "Em linha";
        }
    }
    private static class VisualMovement {
        LocalTime start, end; Point2D p1, p2; String fromStation, destStation;
        VisualMovement(LocalTime s, LocalTime e, Point2D p1, Point2D p2, String st1, String st2) { this.start = s; this.end = e; this.p1 = p1; this.p2 = p2; this.fromStation = st1; this.destStation = st2; }
    }
}