package pt.ipp.isep.dei.UI.gui.utils;

import javafx.animation.AnimationTimer;
import javafx.animation.FadeTransition;
import javafx.animation.PauseTransition;
import javafx.geometry.Insets;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ToggleButton;
import javafx.scene.effect.DropShadow;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.util.Duration;
import pt.ipp.isep.dei.domain.Train;

import java.text.Normalizer;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RailMapVisualizer extends StackPane {

    // --- COMPONENTES UI ---
    private final Canvas canvas;
    private final Pane canvasPane;
    private final VBox notificationContainer; // Nova área de logs flutuantes
    private final VBox conflictPanel;         // Modal de Conflito

    // --- DADOS ---
    private final Map<String, Point2D> stationCoordinates = new HashMap<>();
    private final Map<String, Point2D> autoGeneratedCoordinates = new HashMap<>();
    private final List<VisualSegment> segments = new ArrayList<>();
    private final List<VisualTrain> allTrains = new ArrayList<>();

    // Registo de Conflitos (Lido do Report)
    private final Map<String, ConflictInfo> conflictRegistry = new HashMap<>();

    // --- CÂMARA ---
    private double scale = 0.5;
    private double translateX = 0, translateY = 0;
    private double targetScale = 0.5;
    private double targetTranslateX = 0, targetTranslateY = 0;
    private boolean autoCameraMode = true;
    private double lastMouseX, lastMouseY;

    // --- SIMULAÇÃO ---
    private LocalTime simulationTime;
    private LocalTime maxSimulationTime;
    private double speedFactor = 50.0;
    private double userSpeedSetting = 50.0;
    private AnimationTimer timer;
    private boolean isFinished = false;

    // --- ESTADO CRÍTICO (VAR) ---
    private boolean isPausedByConflict = false;
    private boolean isSlowMotionReplay = false;
    private VisualTrain conflictFocusTrain = null;
    private long slowMotionEndTime = 0;

    // --- CONTROLOS ---
    private final Button btnZoomIn, btnZoomOut;
    private final ToggleButton btnAutoCam;
    private final Label clockLabel;

    public RailMapVisualizer() {
        this.setStyle("-fx-background-color: #0f172a;"); // Fundo Slate Dark

        // 1. Layer Mapa
        this.canvasPane = new Pane();
        this.canvas = new Canvas(800, 600);
        this.canvasPane.getChildren().add(canvas);
        canvas.widthProperty().bind(this.widthProperty());
        canvas.heightProperty().bind(this.heightProperty());

        setupRealisticMapCoordinates();

        // 2. Layer HUD (Notificações Flutuantes - Topo Esquerdo)
        this.notificationContainer = new VBox(5);
        this.notificationContainer.setPadding(new Insets(20));
        this.notificationContainer.setAlignment(Pos.TOP_LEFT);
        this.notificationContainer.setPickOnBounds(false); // Permite clicar através
        this.notificationContainer.setMaxHeight(400);

        // 3. Layer Controlos (Topo Centro/Direita)
        this.btnZoomIn = createGlassButton("+");
        this.btnZoomIn.setOnAction(e -> manualZoom(1.2));
        this.btnZoomOut = createGlassButton("-");
        this.btnZoomOut.setOnAction(e -> manualZoom(0.8));

        this.btnAutoCam = new ToggleButton("AUTO CAM");
        this.btnAutoCam.setSelected(true);
        this.btnAutoCam.setStyle("-fx-background-color: rgba(16, 185, 129, 0.2); -fx-text-fill: #10b981; -fx-font-weight: bold; -fx-border-color: rgba(16, 185, 129, 0.4); -fx-border-radius: 5; -fx-background-radius: 5;");
        this.btnAutoCam.selectedProperty().addListener((obs, old, isSelected) -> autoCameraMode = isSelected);

        this.clockLabel = new Label("00:00:00");
        this.clockLabel.setStyle("-fx-text-fill: white; -fx-font-family: 'Monospaced'; -fx-font-size: 28px; -fx-font-weight: bold; -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.8), 5, 0, 0, 1);");

        HBox controlsBox = new HBox(10, btnZoomIn, btnZoomOut, btnAutoCam, clockLabel);
        controlsBox.setAlignment(Pos.TOP_RIGHT);
        controlsBox.setPadding(new Insets(20));
        controlsBox.setPickOnBounds(false);

        // 4. Layer Modal (Centro)
        this.conflictPanel = createConflictPanel();

        // Adicionar tudo ao StackPane pela ordem correta
        this.getChildren().addAll(canvasPane, notificationContainer, controlsBox, conflictPanel);

        // Alinhar os controlos no StackPane
        StackPane.setAlignment(controlsBox, Pos.TOP_RIGHT);
        StackPane.setAlignment(notificationContainer, Pos.TOP_LEFT);
        StackPane.setAlignment(conflictPanel, Pos.CENTER);

        setupInteraction();
    }

    // --- SISTEMA DE NOTIFICAÇÕES (MODERNO) ---
    public void addLog(String msg, boolean isCritical) {
        Label lbl = new Label(msg);
        lbl.setFont(Font.font("Arial", FontWeight.BOLD, 12));
        lbl.setPadding(new Insets(8, 12, 8, 12));
        lbl.setWrapText(true);
        lbl.setMaxWidth(350);

        // Estilo diferente para critical
        if (isCritical) {
            lbl.setStyle("-fx-background-color: rgba(239, 68, 68, 0.85); -fx-text-fill: white; -fx-background-radius: 8; -fx-border-color: #ef4444; -fx-border-radius: 8; -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.5), 5, 0, 0, 0);");
        } else {
            lbl.setStyle("-fx-background-color: rgba(15, 23, 42, 0.8); -fx-text-fill: #e2e8f0; -fx-background-radius: 6; -fx-border-color: #334155; -fx-border-radius: 6;");
        }

        // Animação de Entrada
        FadeTransition ftIn = new FadeTransition(Duration.millis(300), lbl);
        ftIn.setFromValue(0);
        ftIn.setToValue(1);
        ftIn.play();

        // Auto-Destruição após 5 segundos
        PauseTransition delay = new PauseTransition(Duration.seconds(isCritical ? 10 : 5));
        delay.setOnFinished(e -> {
            FadeTransition ftOut = new FadeTransition(Duration.millis(500), lbl);
            ftOut.setFromValue(1);
            ftOut.setToValue(0);
            ftOut.setOnFinished(ev -> notificationContainer.getChildren().remove(lbl));
            ftOut.play();
        });
        delay.play();

        notificationContainer.getChildren().add(0, lbl); // Adiciona no topo

        // Limita a 5 mensagens visíveis para não poluir
        if (notificationContainer.getChildren().size() > 6) {
            notificationContainer.getChildren().remove(6);
        }
    }

    private VBox createConflictPanel() {
        VBox panel = new VBox(15);
        panel.setAlignment(Pos.CENTER);
        panel.setMaxSize(450, 250);
        panel.setStyle("-fx-background-color: rgba(15, 23, 42, 0.98); -fx-background-radius: 15; -fx-border-color: #ef4444; -fx-border-width: 2; -fx-border-radius: 15; -fx-effect: dropshadow(three-pass-box, rgba(239, 68, 68, 0.6), 50, 0, 0, 0);");

        Label icon = new Label("⚠ CONFLITO DETETADO");
        icon.setStyle("-fx-text-fill: #ef4444; -fx-font-size: 22px; -fx-font-weight: bold;");

        Label desc = new Label("A aguardar resolução de tráfego...");
        desc.setId("conflictDesc"); // Para acesso posterior
        desc.setStyle("-fx-text-fill: #cbd5e1; -fx-font-size: 14px; -fx-text-alignment: center;");
        desc.setWrapText(true);

        Button btn = new Button("VISUALIZAR AÇÃO (1x)");
        btn.setStyle("-fx-background-color: white; -fx-text-fill: #0f172a; -fx-font-weight: bold; -fx-padding: 10 20; -fx-background-radius: 20; -fx-cursor: hand;");
        btn.setOnAction(e -> {
            panel.setVisible(false);
            isPausedByConflict = false;
            isSlowMotionReplay = true;
            speedFactor = 1.0;
            slowMotionEndTime = System.currentTimeMillis() + 8000;
            addLog("▶ Retomando em Velocidade Real", false);
        });

        panel.getChildren().addAll(icon, desc, btn);
        panel.setVisible(false);
        return panel;
    }

    // --- COORDENADAS (LAYOUT OTIMIZADO) ---
    private String normalize(String s) {
        if (s == null) return "";
        String temp = Normalizer.normalize(s, Normalizer.Form.NFD);
        Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+");
        return pattern.matcher(temp).replaceAll("").toLowerCase().trim().replace(" - ", " ").replace("-", " ");
    }

    private void setupRealisticMapCoordinates() {
        // Mapa esticado verticalmente para melhor visualização
        addStation("Valença", 100, 50);
        addStation("São Pedro da Torre", 90, 100);
        addStation("Caminha", 80, 180); // Mais espaço
        addStation("Viana do Castelo", 60, 300); // Viana bem destacada
        addStation("Darque", 65, 340);
        addStation("Barcelos", 90, 440);
        addStation("Nine", 150, 500);
        addStation("Braga", 250, 480);
        addStation("Famalicão", 150, 560);
        addStation("Trofa", 150, 620);
        addStation("Guimarães", 320, 580);
        addStation("Santo Tirso", 250, 600);
        addStation("Ermesinde", 160, 720);
        addStation("Contumil", 140, 780);
        addStation("Porto Campanhã", 130, 820);
        addStation("Porto São Bento", 80, 840);
        addStation("Vila Nova de Gaia", 130, 880);
        addStation("Espinho", 110, 950);
        addStation("Aveiro", 90, 1200);
        addStation("Coimbra B", 90, 1400);
        addStation("Lisboa Oriente", 60, 2000);
    }

    private void addStation(String name, double x, double y) {
        stationCoordinates.put(normalize(name), new Point2D(x, y));
    }

    private Point2D getCoordinates(String name) {
        String key = normalize(name);
        if (stationCoordinates.containsKey(key)) return stationCoordinates.get(key);
        for (String k : stationCoordinates.keySet()) if (k.contains(key) || key.contains(k)) return stationCoordinates.get(k);
        if (!autoGeneratedCoordinates.containsKey(key)) {
            autoGeneratedCoordinates.put(key, new Point2D(600, 200 + autoGeneratedCoordinates.size() * 50));
        }
        return autoGeneratedCoordinates.get(key);
    }

    // --- CARREGAMENTO INTELIGENTE (COM PARSER DE CONFLITOS) ---
    public void loadSchedule(Map<Train, List<String>> trainSchedules, LocalTime time) {
        segments.clear();
        allTrains.clear();
        conflictRegistry.clear();
        notificationContainer.getChildren().clear();

        conflictPanel.setVisible(false);
        isFinished = false;

        LocalTime minT = LocalTime.MAX;
        LocalTime maxT = LocalTime.MIN;

        // 1. PARSER DE CONFLITOS (Lê a secção "CONFLICT AND DELAY REPORT")
        // Exemplo: • [Trip TESTE123] Delay:  4 min in Viana do Castelo due to [Trip TESTEEE]
        Pattern delayPattern = Pattern.compile("\\[Trip (.*?)\\] Delay:\\s+(\\d+) min in (.*?) due to");

        for (List<String> logs : trainSchedules.values()) {
            for (String line : logs) {
                Matcher m = delayPattern.matcher(line);
                if (m.find()) {
                    String trainId = m.group(1).trim();
                    int minutes = Integer.parseInt(m.group(2).trim());
                    String station = m.group(3).trim();
                    conflictRegistry.put(trainId, new ConflictInfo(station, minutes));
                    System.out.println("⚠️ CONFLITO REGISTADO: " + trainId + " em " + station + " (" + minutes + "m)");
                }
            }
        }

        // 2. PARSER DE MOVIMENTOS
        for (Map.Entry<Train, List<String>> entry : trainSchedules.entrySet()) {
            Train train = entry.getKey();
            VisualTrain vt = new VisualTrain(train);
            boolean hasData = false;

            for (String logLine : entry.getValue()) {
                if (!logLine.contains("|")) continue;
                String[] parts = logLine.split("\\|");
                if (parts.length < 7) continue;

                try {
                    String startSt = parts[1].trim();
                    String endSt = parts[2].trim();
                    String tEntry = parts[5].trim();
                    String tExit = parts[6].trim();

                    if (tEntry.equals("N/A") || tExit.equals("N/A")) continue;
                    LocalTime in = LocalTime.parse(tEntry);
                    LocalTime out = LocalTime.parse(tExit);

                    if (in.isBefore(minT)) minT = in;
                    if (out.isAfter(maxT)) maxT = out;

                    Point2D p1 = getCoordinates(startSt);
                    Point2D p2 = getCoordinates(endSt);

                    if (segments.stream().noneMatch(s -> s.matches(startSt, endSt))) {
                        boolean isDouble = parts[3].toLowerCase().contains("double");
                        segments.add(new VisualSegment(startSt, endSt, p1, p2, isDouble));
                    }
                    vt.addMovement(in, out, p1, p2, startSt, endSt);
                    hasData = true;
                } catch (Exception e) {}
            }

            if (hasData) {
                // Verificar se este comboio tem conflito registado no início
                ConflictInfo conflict = conflictRegistry.get(train.getTrainId());
                if (conflict != null && !vt.movements.isEmpty()) {
                    String firstStation = vt.movements.get(0).fromStation;
                    // Se o conflito for na estação de partida, injeta o atraso inicial
                    if (normalize(firstStation).contains(normalize(conflict.station)) || normalize(conflict.station).contains(normalize(firstStation))) {
                        vt.initialDelayMinutes = conflict.delayMinutes;
                        vt.hasInitialConflict = true;
                        // O tempo de início "Visual" passa a ser: Partida Real - Delay
                        LocalTime realStart = vt.movements.get(0).start;
                        vt.scheduledStart = realStart.minusMinutes(conflict.delayMinutes);
                    }
                }
                allTrains.add(vt);
            }
        }

        this.simulationTime = (minT == LocalTime.MAX) ? LocalTime.of(8, 0) : minT.minusSeconds(60);
        this.maxSimulationTime = maxT;

        autoCameraMode = true;
        btnAutoCam.setSelected(true);
        scale = 0.5; translateX = 0; translateY = 0;
        updateCameraLogic();
        scale = targetScale; translateX = targetTranslateX; translateY = targetTranslateY;
        updateFrame();

        addLog("Simulação carregada. Pronto.", false);
    }

    // --- LOOP PRINCIPAL ---
    public void startAnimation() {
        if (timer != null) timer.stop();
        if (allTrains.isEmpty()) return;

        timer = new AnimationTimer() {
            private long lastUpdate = 0;

            @Override
            public void handle(long now) {
                if (lastUpdate == 0) { lastUpdate = now; return; }
                double elapsed = (now - lastUpdate) / 1_000_000_000.0;
                lastUpdate = now;

                if (simulationTime != null && !isFinished) {

                    if (isSlowMotionReplay && System.currentTimeMillis() > slowMotionEndTime) {
                        isSlowMotionReplay = false;
                        speedFactor = userSpeedSetting;
                        conflictFocusTrain = null;
                        addLog("Velocidade normal restaurada.", false);
                    }

                    checkDepartures();

                    // Verifica conflitos SE não estivermos já pausados
                    if (!isPausedByConflict && !isSlowMotionReplay) {
                        checkForConflicts();
                    }

                    if (!isPausedByConflict) {
                        if (simulationTime.isAfter(maxSimulationTime)) {
                            isFinished = true;
                            addLog("Simulação Terminada.", false);
                        } else {
                            long secondsToAdd = (long) (elapsed * speedFactor);
                            simulationTime = simulationTime.plusSeconds(secondsToAdd);
                        }
                    }
                }

                updateCameraLogic();
                applyCameraSmoothing();
                updateFrame();
            }
        };
        timer.start();
    }

    private void checkDepartures() {
        for (VisualTrain vt : allTrains) {
            if (vt.movements.isEmpty()) continue;

            // Usa o Scheduled Start se existir (caso de conflito inicial), senão o Real
            LocalTime refStart = (vt.scheduledStart != null) ? vt.scheduledStart : vt.movements.get(0).start;

            long minToStart = ChronoUnit.MINUTES.between(simulationTime, refStart);
            if (minToStart >= 0 && minToStart <= 15 && !vt.notifiedStart) {
                addLog("Partida: " + vt.train.getTrainId() + " de " + vt.movements.get(0).fromStation + " em " + minToStart + " min.", false);
                vt.notifiedStart = true;
            }
        }
    }

    private void checkForConflicts() {
        for (VisualTrain vt : allTrains) {
            // Lógica crítica para o caso das 15:00
            // Se tem conflito inicial E hora atual >= hora agendada E hora atual < hora real de partida
            if (vt.hasInitialConflict &&
                    !simulationTime.isBefore(vt.scheduledStart) &&
                    simulationTime.isBefore(vt.movements.get(0).start) &&
                    !vt.isWaitNotified) {

                triggerConflictPause(vt, "Atraso na partida (" + vt.initialDelayMinutes + " min) - Aguarda via livre");
                vt.isWaitNotified = true;
                break;
            }

            // Lógica normal de espera entre estações
            if (vt.isWaitingBetweenStations(simulationTime) && !vt.isWaitNotified) {
                triggerConflictPause(vt, "Cruzamento / Gestão de Tráfego");
                vt.isWaitNotified = true;
                break;
            }

            // Reset flag
            if (!vt.hasInitialConflict && !vt.isWaitingBetweenStations(simulationTime)) {
                vt.isWaitNotified = false;
            }
        }
    }

    private void triggerConflictPause(VisualTrain t, String reason) {
        isPausedByConflict = true;
        conflictFocusTrain = t;

        Label desc = (Label) conflictPanel.lookup("#conflictDesc");
        if(desc != null) desc.setText(t.train.getTrainId() + " parado em " + t.getCurrentLocationName(simulationTime) + ".\n" + reason);

        addLog("⚠ CONFLITO: " + t.train.getTrainId() + " (" + reason + ")", true);

        conflictPanel.setVisible(true);
        conflictPanel.toFront();
        autoCameraMode = true; // Força foco
    }

    // --- VISUALIZAÇÃO ---
    private void updateFrame() {
        GraphicsContext gc = canvas.getGraphicsContext2D();
        double w = getWidth(); double h = getHeight();
        gc.setFill(Color.web("#0f172a"));
        gc.fillRect(0, 0, w, h);
        gc.save();
        gc.translate(translateX, translateY);
        gc.scale(scale, scale);
        double viewScale = 1.0 / Math.max(0.3, scale);

        gc.setLineCap(javafx.scene.shape.StrokeLineCap.ROUND);

        // Linhas
        for (VisualSegment s : segments) {
            double width = (s.isDouble ? 4.0 : 2.5) * viewScale;
            gc.setStroke(Color.rgb(255,255,255,0.1));
            gc.setLineWidth(width + 2);
            gc.strokeLine(s.p1.getX(), s.p1.getY(), s.p2.getX(), s.p2.getY());
            Color c = s.isDouble ? Color.web("#3b82f6") : Color.web("#f59e0b");
            if (isPausedByConflict) c = c.darker().desaturate();
            gc.setStroke(c);
            gc.setLineWidth(width);
            gc.strokeLine(s.p1.getX(), s.p1.getY(), s.p2.getX(), s.p2.getY());
        }

        // Estações
        Set<String> drawn = new HashSet<>();
        for (VisualSegment s : segments) {
            drawStation(gc, s.origName, s.p1, viewScale, drawn);
            drawStation(gc, s.destName, s.p2, viewScale, drawn);
        }

        // Comboios
        for (VisualTrain t : allTrains) drawTrain(gc, t, viewScale);
        gc.restore();

        if (simulationTime != null) clockLabel.setText(simulationTime.format(DateTimeFormatter.ofPattern("HH:mm:ss")));
    }

    private void drawStation(GraphicsContext gc, String name, Point2D pos, double vs, Set<String> drawn) {
        if (drawn.contains(name)) return;
        drawn.add(name);
        double r = 3.5 * vs;
        gc.setFill(Color.WHITE);
        gc.fillOval(pos.getX() - r, pos.getY() - r, r*2, r*2);
        if (scale > 0.4) {
            gc.setFont(Font.font("Arial", 10 * vs));
            gc.setFill(Color.web("#94a3b8"));
            gc.fillText(name, pos.getX() + r + 4, pos.getY() + 3*vs);
        }
    }

    private void drawTrain(GraphicsContext gc, VisualTrain t, double vs) {
        Point2D p = t.getPosition(simulationTime);
        if (p == null) return;

        boolean waiting = t.isWaitingOrDelayed(simulationTime);
        boolean isFocus = (t == conflictFocusTrain);

        if (isPausedByConflict && !isFocus) gc.setGlobalAlpha(0.2);

        double r = (isFocus ? 12.0 : 7.0) * vs;
        Color c = waiting ? Color.web("#ef4444") : Color.web("#10b981");

        // Efeito Pulse se estiver parado/conflito
        if (waiting || isFocus) {
            double pulse = r * (1.3 + 0.3 * Math.sin(System.currentTimeMillis() / 100.0));
            gc.setStroke(Color.web("#ef4444", 0.7));
            gc.setLineWidth(2 * vs);
            gc.strokeOval(p.getX() - pulse, p.getY() - pulse, pulse*2, pulse*2);
        }

        gc.setFill(c);
        gc.setEffect(new DropShadow(8 * vs, c));
        gc.fillOval(p.getX() - r, p.getY() - r, r*2, r*2);
        gc.setEffect(null);

        if (scale > 0.5 || isFocus || waiting) {
            gc.setFill(Color.WHITE);
            gc.setFont(Font.font("Arial", FontWeight.BOLD, 10 * vs));
            gc.fillText(t.train.getTrainId(), p.getX() + r + 2, p.getY() - r);
        }
        gc.setGlobalAlpha(1.0);
    }

    // --- CÂMARA ---
    private void updateCameraLogic() {
        if (conflictFocusTrain != null) {
            Point2D pos = conflictFocusTrain.getPosition(simulationTime);
            if (pos != null) {
                double w = getWidth(); double h = getHeight();
                targetScale = 2.0;
                targetTranslateX = (w/2.0) - (pos.getX() * targetScale);
                targetTranslateY = (h/2.0) - (pos.getY() * targetScale);
            }
            return;
        }
        if (!autoCameraMode) return;

        List<Point2D> targets = new ArrayList<>();
        if (simulationTime != null) {
            for (VisualTrain vt : allTrains) {
                if (vt.isActive(simulationTime) || vt.hasInitialConflict) {
                    Point2D p = vt.getPosition(simulationTime);
                    if (p != null) targets.add(p);
                }
            }
        }
        if (targets.isEmpty()) return;

        double minX = Double.MAX_VALUE, maxX = -Double.MAX_VALUE, minY = Double.MAX_VALUE, maxY = -Double.MAX_VALUE;
        for (Point2D p : targets) {
            minX = Math.min(minX, p.getX()); maxX = Math.max(maxX, p.getX());
            minY = Math.min(minY, p.getY()); maxY = Math.max(maxY, p.getY());
        }
        double pad = 150;
        double cw = Math.max(100, maxX - minX);
        double ch = Math.max(100, maxY - minY);
        double sx = (getWidth() - pad) / cw;
        double sy = (getHeight() - pad) / ch;
        double ns = Math.min(sx, sy);
        targetScale = Math.max(0.3, Math.min(ns, 1.5));
        targetTranslateX = (getWidth()/2.0) - ((minX + cw/2.0) * targetScale);
        targetTranslateY = (getHeight()/2.0) - ((minY + ch/2.0) * targetScale);
    }

    private void applyCameraSmoothing() {
        double smooth = (isPausedByConflict) ? 0.2 : 0.05;
        scale += (targetScale - scale) * smooth;
        translateX += (targetTranslateX - translateX) * smooth;
        translateY += (targetTranslateY - translateY) * smooth;
    }

    private void setupInteraction() {
        canvasPane.setOnScroll(e -> {
            if (!isPausedByConflict) { autoCameraMode = false; btnAutoCam.setSelected(false); targetScale *= (e.getDeltaY() > 0 ? 1.1 : 0.9); }
        });
        canvasPane.setOnMousePressed(e -> { lastMouseX = e.getX(); lastMouseY = e.getY(); });
        canvasPane.setOnMouseDragged(e -> {
            if (!isPausedByConflict) { autoCameraMode = false; btnAutoCam.setSelected(false); targetTranslateX += (e.getX() - lastMouseX); targetTranslateY += (e.getY() - lastMouseY); lastMouseX = e.getX(); lastMouseY = e.getY(); updateFrame(); }
        });
    }

    private Button createGlassButton(String text) {
        Button btn = new Button(text);
        btn.setStyle("-fx-background-color: rgba(255, 255, 255, 0.1); -fx-text-fill: white; -fx-font-weight: bold; -fx-min-width: 30px; -fx-background-radius: 5; -fx-border-color: rgba(255,255,255,0.2); -fx-border-radius: 5;");
        return btn;
    }

    public void setSpeedFactor(double f) { userSpeedSetting = f; if(!isSlowMotionReplay && !isPausedByConflict) speedFactor = f; }
    public void stopAnimation() { if(timer != null) timer.stop(); }
    private void manualZoom(double f) { autoCameraMode = false; btnAutoCam.setSelected(false); targetScale *= f; }

    // --- HELPER CLASSES ---
    private static class ConflictInfo {
        String station; int delayMinutes;
        ConflictInfo(String s, int d) { this.station = s; this.delayMinutes = d; }
    }

    private static class VisualSegment {
        String origName, destName; Point2D p1, p2; boolean isDouble;
        VisualSegment(String s, String e, Point2D p1, Point2D p2, boolean d) { this.origName = s; this.destName = e; this.p1 = p1; this.p2 = p2; this.isDouble = d; }
        boolean matches(String s, String e) { return (origName.equalsIgnoreCase(s) && destName.equalsIgnoreCase(e)) || (origName.equalsIgnoreCase(e) && destName.equalsIgnoreCase(s)); }
    }

    private static class VisualTrain {
        Train train;
        List<javafx.util.Pair<LocalTime, LocalTime>> movementsTime = new ArrayList<>();
        List<VisualMovement> movements = new ArrayList<>();

        boolean hasInitialConflict = false;
        int initialDelayMinutes = 0;
        LocalTime scheduledStart = null;

        boolean notifiedStart = false;
        boolean isWaitNotified = false;

        VisualTrain(Train t) { this.train = t; }

        void addMovement(LocalTime s, LocalTime e, Point2D p1, Point2D p2, String st1, String st2) {
            movements.add(new VisualMovement(s, e, p1, p2, st1, st2));
            movements.sort(Comparator.comparing(m -> m.start));
        }

        boolean isWaitingOrDelayed(LocalTime t) {
            if (t == null || movements.isEmpty()) return false;
            // 1. Atraso Inicial
            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) return true;
            // 2. Espera Intermédia
            return isWaitingBetweenStations(t);
        }

        boolean isWaitingBetweenStations(LocalTime t) {
            for (int i = 0; i < movements.size() - 1; i++) {
                if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i+1).start)) return true;
            }
            return false;
        }

        boolean isActive(LocalTime t) {
            if (t == null || movements.isEmpty()) return false;
            // Ativo se estiver em movimento OU em conflito inicial
            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) return true;
            for (VisualMovement m : movements) if (!t.isBefore(m.start) && !t.isAfter(m.end)) return true;
            return false;
        }

        Point2D getPosition(LocalTime t) {
            if (t == null || movements.isEmpty()) return null;

            // Caso especial: Atraso Inicial (Desenha na origem)
            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) {
                // Mostra se estivermos a <30 min da hora real de partida
                if (java.time.Duration.between(t, movements.get(0).start).toMinutes() <= 30) {
                    return movements.get(0).p1;
                }
                return null;
            }

            // Movimento normal
            for (VisualMovement m : movements) {
                if (!t.isBefore(m.start) && !t.isAfter(m.end)) {
                    // CORREÇÃO AQUI: Usar java.time.Duration explicitamente
                    long totalSeconds = java.time.Duration.between(m.start, m.end).getSeconds();
                    long currentSeconds = java.time.Duration.between(m.start, t).getSeconds();

                    // Evitar divisão por zero
                    double r = (totalSeconds <= 0) ? 1.0 : (double) currentSeconds / totalSeconds;

                    return new Point2D(
                            m.p1.getX() + (m.p2.getX() - m.p1.getX()) * r,
                            m.p1.getY() + (m.p2.getY() - m.p1.getY()) * r
                    );
                }
            }

            // Parado entre estações (mostra na estação onde chegou)
            for (int i = 0; i < movements.size() - 1; i++) {
                if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i + 1).start)) {
                    return movements.get(i).p2;
                }
            }

            // Pré-partida normal (15 min antes)
            if (!movements.isEmpty() && t.isBefore(movements.get(0).start)) {
                LocalTime ref = hasInitialConflict ? scheduledStart : movements.get(0).start;
                // CORREÇÃO AQUI TAMBÉM
                if (java.time.Duration.between(t, ref).toMinutes() <= 15) {
                    return movements.get(0).p1;
                }
            }
            return null;
        }

        String getCurrentLocationName(LocalTime t) {
            if (t == null || movements.isEmpty()) return "?";
            if (hasInitialConflict && t.isBefore(movements.get(0).start)) return movements.get(0).fromStation;
            for (int i = 0; i < movements.size() - 1; i++) {
                if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i+1).start)) return movements.get(i).destStation;
            }
            return "Linha";
        }
    }

    private static class VisualMovement {
        LocalTime start, end; Point2D p1, p2; String fromStation, destStation;
        VisualMovement(LocalTime s, LocalTime e, Point2D p1, Point2D p2, String st1, String st2) { this.start = s; this.end = e; this.p1 = p1; this.p2 = p2; this.fromStation = st1; this.destStation = st2; }
    }
}