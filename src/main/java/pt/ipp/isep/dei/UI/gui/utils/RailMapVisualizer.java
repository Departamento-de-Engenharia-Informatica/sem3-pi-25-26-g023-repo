package pt.ipp.isep.dei.UI.gui.utils;

import javafx.animation.AnimationTimer;
import javafx.geometry.Point2D;
import javafx.geometry.VPos;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.ToggleButton;
import javafx.scene.layout.Pane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.TextAlignment;
import pt.ipp.isep.dei.domain.Train;

import java.time.Duration;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.stream.Collectors;

public class RailMapVisualizer extends Pane {

    private final Canvas canvas;
    private final Map<String, Point2D> stationCoordinates = new HashMap<>();
    private final Map<String, Point2D> autoGeneratedCoordinates = new HashMap<>();
    private final List<VisualSegment> segments = new ArrayList<>();
    private final List<VisualTrain> allTrains = new ArrayList<>();

    // --- NOTIFICA√á√ïES ---
    private final Queue<GameNotification> notifications = new ConcurrentLinkedQueue<>();

    // --- C√ÇMARA ---
    private double scale = 1.0;
    private double translateX = 0.0;
    private double translateY = 0.0;
    private double targetScale = 1.0;
    private double targetTranslateX = 0.0;
    private double targetTranslateY = 0.0;
    private boolean autoCameraMode = true;
    private double lastMouseX, lastMouseY;

    // --- SIMULA√á√ÉO ---
    private LocalTime simulationTime;
    private LocalTime maxSimulationTime;
    private double speedFactor = 50.0;
    private AnimationTimer timer;
    private boolean isRunning = false;
    private boolean isFinished = false;

    // --- ESTADO DE CONFLITO ---
    private boolean isPausedByConflict = false;
    private VisualTrain conflictFocusTrain = null;
    private boolean isSkippingTime = false;

    // UI
    private final Button btnZoomIn;
    private final Button btnZoomOut;
    private final ToggleButton btnAutoCam;
    private final Button btnResume;

    public RailMapVisualizer() {
        this.canvas = new Canvas(0, 0);

        // BOT√ïES UI - FICAM NO CANTO SUPERIOR ESQUERDO
        this.btnZoomIn = createButton("+", e -> manualZoom(1.2));
        this.btnZoomOut = createButton("-", e -> manualZoom(0.8));

        this.btnAutoCam = new ToggleButton("Auto Cam");
        this.btnAutoCam.setSelected(true);
        this.btnAutoCam.setStyle("-fx-background-color: #2c3e50; -fx-text-fill: white; -fx-font-size: 10px; -fx-cursor: hand; -fx-border-color: #555;");
        this.btnAutoCam.selectedProperty().addListener((obs, old, isSelected) -> autoCameraMode = isSelected);

        this.btnResume = new Button("RESOLVER CONFLITO (CONTINUAR)");
        this.btnResume.setStyle("-fx-background-color: #c0392b; -fx-text-fill: white; -fx-font-weight: bold; -fx-cursor: hand; -fx-padding: 10 20 10 20; -fx-font-size: 14px; -fx-background-radius: 5;");
        this.btnResume.setVisible(false);
        this.btnResume.setOnAction(e -> resolveConflictAndResume());

        VBox controls = new VBox(5, btnZoomIn, btnZoomOut, btnAutoCam);
        controls.setLayoutX(20);
        controls.setLayoutY(20);

        getChildren().addAll(canvas, controls, btnResume);

        canvas.widthProperty().bind(this.widthProperty());
        canvas.heightProperty().bind(this.heightProperty());
        this.widthProperty().addListener(e -> updateFrame());
        this.heightProperty().addListener(e -> updateFrame());

        setStyle("-fx-background-color: #1e1e1e;");

        setupInteraction();
        setupMapCoordinates();
    }

    private Button createButton(String text, javafx.event.EventHandler<javafx.event.ActionEvent> action) {
        Button btn = new Button(text);
        btn.setStyle("-fx-background-color: rgba(60, 60, 60, 0.8); -fx-text-fill: white; -fx-font-weight: bold; -fx-min-width: 30px; -fx-cursor: hand; -fx-border-color: #777;");
        btn.setOnAction(action);
        return btn;
    }

    private void manualZoom(double factor) {
        autoCameraMode = false;
        btnAutoCam.setSelected(false);
        targetScale *= factor;
        if(targetScale < 0.05) targetScale = 0.05;
        if(targetScale > 5.0) targetScale = 5.0;
        scale = targetScale;
        updateFrame();
    }

    private void resolveConflictAndResume() {
        isPausedByConflict = false;
        conflictFocusTrain = null;
        btnResume.setVisible(false);
        this.speedFactor = 1.0;
        addNotification("Velocidade normalizada (1x)", 3000);
    }

    private void updateCameraLogic() {
        if (isPausedByConflict && conflictFocusTrain != null) {
            Point2D pos = conflictFocusTrain.getCurrentPositionOrLastStation(simulationTime);
            if (pos != null) {
                double width = getWidth();
                double height = getHeight();
                this.targetScale = 2.5;
                this.targetTranslateX = (width / 2.0) - (pos.getX() * this.targetScale);
                this.targetTranslateY = (height / 2.0) - (pos.getY() * this.targetScale);
                return;
            }
        }

        if (!autoCameraMode) return;

        List<Point2D> activePoints = new ArrayList<>();
        if (simulationTime != null) {
            for (VisualTrain vt : allTrains) {
                if (vt.isActive(simulationTime) || vt.isWaiting(simulationTime)) {
                    Point2D pos = vt.getCurrentPositionOrLastStation(simulationTime);
                    if (pos != null) activePoints.add(pos);
                }
            }
        }

        double minX = Double.MAX_VALUE, maxX = -Double.MAX_VALUE;
        double minY = Double.MAX_VALUE, maxY = -Double.MAX_VALUE;

        if (activePoints.isEmpty()) {
            Point2D porto = getCoordinates("Porto Campanha"); // Use normalized key
            if (porto != null) {
                minX = porto.getX() - 400; maxX = porto.getX() + 400;
                minY = porto.getY() - 400; maxY = porto.getY() + 400;
            } else {
                minX = 0; maxX = 1000; minY = 0; maxY = 1000;
            }
        } else {
            for (Point2D p : activePoints) {
                minX = Math.min(minX, p.getX());
                maxX = Math.max(maxX, p.getX());
                minY = Math.min(minY, p.getY());
                maxY = Math.max(maxY, p.getY());
            }
        }

        if (minX == Double.MAX_VALUE) return;

        double padding = activePoints.size() > 1 ? 150 : 400;
        double width = getWidth();
        double height = getHeight();
        if (width == 0 || height == 0) return;

        double contentW = maxX - minX;
        double contentH = maxY - minY;
        if (contentW < 100) contentW = 100;
        if (contentH < 100) contentH = 100;

        double availW = width - padding * 2;
        double availH = height - padding * 2;

        double newScale = Math.min(availW / contentW, availH / contentH);
        newScale = Math.max(0.2, Math.min(newScale, 2.5));

        double contentCX = minX + contentW / 2.0;
        double contentCY = minY + contentH / 2.0;

        this.targetScale = newScale;
        this.targetTranslateX = (width / 2.0) - (contentCX * newScale);
        this.targetTranslateY = (height / 2.0) - (contentCY * newScale);
    }

    private void applyCameraSmoothing() {
        double smooth = isPausedByConflict ? 0.2 : 0.08;
        if (Math.abs(targetScale - scale) > 0.001) {
            scale += (targetScale - scale) * smooth;
            translateX += (targetTranslateX - translateX) * smooth;
            translateY += (targetTranslateY - translateY) * smooth;
        }
    }

    private void setupInteraction() {
        this.setOnScroll(event -> {
            if (!isPausedByConflict) {
                autoCameraMode = false;
                btnAutoCam.setSelected(false);
                double zoomFactor = (event.getDeltaY() > 0) ? 1.1 : 0.9;
                targetScale *= zoomFactor;
                event.consume();
            }
        });
        this.setOnMousePressed(event -> { lastMouseX = event.getX(); lastMouseY = event.getY(); });
        this.setOnMouseDragged(event -> {
            if (!isPausedByConflict) {
                autoCameraMode = false;
                btnAutoCam.setSelected(false);
                targetTranslateX += (event.getX() - lastMouseX);
                targetTranslateY += (event.getY() - lastMouseY);
                translateX = targetTranslateX; translateY = targetTranslateY;
                lastMouseX = event.getX(); lastMouseY = event.getY();
                updateFrame();
            }
        });
    }

    // --- MAPA ---
    // Importante: Usar chaves normalizadas (sem acentos se poss√≠vel, ou strings simples)
    // para evitar falhas de matching.
    private void setupMapCoordinates() {
        addStation("Valen√ßa", 1000, 0);
        addStation("S√£o Pedro da Torre", 1000, 300);
        addStation("Vila Nova de Cerveira", 1000, 600);
        addStation("Caminha", 1000, 900);
        addStation("Viana do Castelo", 1000, 1200);
        addStation("Darque", 1000, 1400);
        addStation("Barcelos", 1000, 1700);
        addStation("Nine", 1000, 2000);

        addStation("Braga", 1300, 2000);
        addStation("Famalic√£o", 1000, 2300);
        addStation("Trofa", 1000, 2600);
        addStation("Santo Tirso", 1200, 2600);
        addStation("Guimar√£es", 1400, 2600);
        addStation("Ermesinde", 1000, 2900);

        addStation("S√£o Gemil", 700, 2900);
        addStation("S√£o Mamede de Infesta", 500, 2900);
        addStation("Le√ßa do Balio", 300, 2900);
        addStation("Leix√µes", 100, 2900);

        addStation("Rio Tinto", 1000, 3100);
        addStation("Contumil", 1000, 3300);

        // CORRE√á√ÉO CR√çTICA: Mapear tanto "Porto Campanh√£" como "Porto - Campanh√£"
        Point2D portoC = new Point2D(1000, 3600);
        stationCoordinates.put("Porto Campanh√£", portoC);
        stationCoordinates.put("Porto - Campanh√£", portoC);
        stationCoordinates.put("Porto Campanha", portoC); // Sem acento por seguran√ßa

        Point2D portoSB = new Point2D(600, 3600);
        stationCoordinates.put("Porto S√£o Bento", portoSB);
        stationCoordinates.put("Porto - S√£o Bento", portoSB);
        stationCoordinates.put("Porto Sao Bento", portoSB);

        addStation("Vila Nova de Gaia", 1000, 3900);
        addStation("Espinho", 1000, 4200);
        addStation("Ovar", 1000, 4500);
        addStation("Aveiro", 1000, 4900);
        addStation("Coimbra-B", 1000, 5400);
        addStation("Pombal", 1000, 5900);
        addStation("Entroncamento", 1000, 6400);
        addStation("Lisboa - Oriente", 1000, 7500);
        addStation("Lisboa - Santa Apol√≥nia", 1000, 7800);
    }

    private void addStation(String name, double x, double y) {
        stationCoordinates.put(name, new Point2D(x, y));
    }

    private Point2D getCoordinates(String name) {
        // 1. Tenta Match Exato
        if (stationCoordinates.containsKey(name)) return stationCoordinates.get(name);

        // 2. Tenta Match Normalizado (remove hifens, espa√ßos extra, lowercase)
        String normalizedInput = normalize(name);
        for (Map.Entry<String, Point2D> entry : stationCoordinates.entrySet()) {
            if (normalize(entry.getKey()).equals(normalizedInput)) {
                return entry.getValue();
            }
        }

        // 3. Tenta Match Parcial Seguro
        for (String key : stationCoordinates.keySet()) {
            if (key.contains(name) || name.contains(key)) return stationCoordinates.get(key);
        }

        // 4. Fallback: Auto-Layout (Nova esta√ß√£o)
        if (!autoGeneratedCoordinates.containsKey(name)) {
            int idx = autoGeneratedCoordinates.size();
            double x = 2500 + (idx % 2) * 400; // Bem longe do mapa principal
            double y = 1000 + (idx / 2) * 300;
            autoGeneratedCoordinates.put(name, new Point2D(x, y));
            addNotification("Nova esta√ß√£o mapeada: " + name, 5000);
        }
        return autoGeneratedCoordinates.get(name);
    }

    private String normalize(String s) {
        return s.toLowerCase().replaceAll("[^a-z0-9]", "");
    }

    public void loadSchedule(Map<Train, List<String>> trainSchedules, LocalTime localTime) {
        this.segments.clear();
        this.allTrains.clear();
        this.autoGeneratedCoordinates.clear();
        this.isFinished = false;
        this.isPausedByConflict = false;
        this.conflictFocusTrain = null;

        LocalTime globalStart = LocalTime.MAX;
        LocalTime globalEnd = LocalTime.MIN;

        for (Map.Entry<Train, List<String>> entry : trainSchedules.entrySet()) {
            Train train = entry.getKey();
            List<String> logs = entry.getValue();
            VisualTrain vTrain = new VisualTrain(train);
            boolean hasSegments = false;
            String dest = "?";

            for (String line : logs) {
                if (!line.contains("|")) continue;
                String[] parts = line.split("\\|");
                if (parts.length < 7) continue;
                try {
                    String startSt = parts[1].trim();
                    String endSt = parts[2].trim();
                    String type = parts[3].trim();
                    String entryStr = parts[5].trim();
                    String exitStr = parts[6].trim();

                    if (startSt.equalsIgnoreCase("START") || startSt.equalsIgnoreCase("END")) continue;
                    if (entryStr.equals("N/A") || exitStr.equals("N/A")) continue;

                    LocalTime tIn = LocalTime.parse(entryStr);
                    LocalTime tOut = LocalTime.parse(exitStr);

                    if (tIn.isBefore(globalStart)) globalStart = tIn;
                    if (tOut.isAfter(globalEnd)) globalEnd = tOut;

                    Point2D p1 = getCoordinates(startSt);
                    Point2D p2 = getCoordinates(endSt);

                    if (segments.stream().noneMatch(s -> s.matches(startSt, endSt))) {
                        segments.add(new VisualSegment(startSt, endSt, p1, p2, type.equalsIgnoreCase("Double")));
                    }

                    vTrain.addMovement(tIn, tOut, p1, p2);
                    dest = endSt;
                    hasSegments = true;
                } catch (Exception e) {}
            }
            if (hasSegments) {
                vTrain.destination = dest;
                allTrains.add(vTrain);
            }
        }

        if (globalStart != LocalTime.MAX) {
            this.simulationTime = globalStart.minusSeconds(30);
            this.maxSimulationTime = globalEnd;
        } else {
            this.simulationTime = LocalTime.of(8, 0);
        }

        autoCameraMode = true;
        btnAutoCam.setSelected(true);
        updateCameraLogic();
        scale = targetScale; translateX = targetTranslateX; translateY = targetTranslateY;
        updateFrame();
    }

    public void startAnimation() {
        if (timer != null) timer.stop();
        if (allTrains.isEmpty()) return;
        isFinished = false;

        timer = new AnimationTimer() {
            private long lastUpdate = 0;
            @Override
            public void handle(long now) {
                if (lastUpdate == 0) { lastUpdate = now; return; }
                double elapsedReal = (now - lastUpdate) / 1_000_000_000.0;
                lastUpdate = now;

                if (simulationTime != null && !isFinished) {
                    Optional<VisualTrain> waiter = allTrains.stream()
                            .filter(t -> t.isWaiting(simulationTime))
                            .findFirst();

                    if (waiter.isPresent()) {
                        if (!isPausedByConflict) {
                            isPausedByConflict = true;
                            conflictFocusTrain = waiter.get();
                            btnResume.setVisible(true);
                            // Centra o bot√£o no ecr√£
                            btnResume.setLayoutX((getWidth() - btnResume.getWidth()) / 2);
                            btnResume.setLayoutY((getHeight() - btnResume.getHeight()) / 2 + 60);
                            addNotification("‚ö† CONFLITO DETETADO! SIMULA√á√ÉO INTERROMPIDA", 60000);
                        }
                    }

                    if (!isPausedByConflict) {
                        long secondsToAdd = (long) (elapsedReal * speedFactor);
                        boolean active = allTrains.stream().anyMatch(t -> t.isActive(simulationTime));
                        boolean anyWait = allTrains.stream().anyMatch(t -> t.isWaiting(simulationTime));

                        if (!active && !anyWait && !isSkippingTime) {
                            LocalTime nextEvent = findNextEvent(simulationTime);
                            if (nextEvent != null) {
                                long gap = ChronoUnit.SECONDS.between(simulationTime, nextEvent);
                                if (gap > 60) {
                                    isSkippingTime = true;
                                    simulationTime = nextEvent.minusSeconds(10);
                                } else {
                                    simulationTime = simulationTime.plusSeconds(secondsToAdd);
                                }
                            } else {
                                isFinished = true;
                            }
                        } else {
                            simulationTime = simulationTime.plusSeconds(secondsToAdd);
                            isSkippingTime = false;
                        }
                    }
                }

                long nowMs = System.currentTimeMillis();
                notifications.removeIf(n -> n.expireTime < nowMs);
                checkDepartures();

                updateCameraLogic();
                applyCameraSmoothing();
                updateFrame();
            }
        };
        timer.start();
        isRunning = true;
    }

    private LocalTime findNextEvent(LocalTime current) {
        return allTrains.stream().flatMap(t -> t.movements.stream()).map(m -> m.start)
                .filter(t -> t.isAfter(current)).min(Comparator.naturalOrder()).orElse(null);
    }

    private void checkDepartures() {
        for (VisualTrain vt : allTrains) {
            if (vt.isAboutToStart(simulationTime, 10) && !vt.notifiedStart) {
                addNotification("Partida: " + vt.train.getTrainId() + " -> " + vt.destination, 5000);
                vt.notifiedStart = true;
            }
        }
    }

    public void addNotification(String msg, long durationMs) {
        notifications.add(new GameNotification(msg, System.currentTimeMillis() + durationMs));
    }

    public void stopAnimation() {
        if (timer != null) timer.stop();
        isRunning = false;
    }

    public void setSpeedFactor(double factor) { this.speedFactor = factor; }

    // --- RENDERIZA√á√ÉO ---
    private void updateFrame() {
        GraphicsContext gc = canvas.getGraphicsContext2D();
        double w = getWidth(); double h = getHeight();

        // 1. Fundo Limpo
        gc.setFill(Color.web("#1e1e1e"));
        gc.fillRect(0,0, w, h);

        // 2. Mundo
        gc.save();
        gc.translate(translateX, translateY);
        gc.scale(scale, scale);

        double viewScale = 1.0 / Math.max(0.3, scale);

        // Linhas
        gc.setLineCap(javafx.scene.shape.StrokeLineCap.ROUND);
        for (VisualSegment seg : segments) {
            double width = (seg.isDouble ? 6.0 : 3.0) * viewScale * 0.5;
            gc.setStroke(Color.web("#333"));
            gc.setLineWidth(width * 1.5);
            gc.strokeLine(seg.p1.getX(), seg.p1.getY(), seg.p2.getX(), seg.p2.getY());

            gc.setStroke(seg.isDouble ? Color.web("#3498db") : Color.web("#e67e22"));
            gc.setLineWidth(width);
            gc.strokeLine(seg.p1.getX(), seg.p1.getY(), seg.p2.getX(), seg.p2.getY());
        }

        Set<String> drawnStations = new HashSet<>();
        for (VisualSegment seg : segments) {
            drawStation(gc, seg.start, seg.p1, viewScale, drawnStations);
            drawStation(gc, seg.end, seg.p2, viewScale, drawnStations);
        }

        for (VisualTrain t : allTrains) {
            drawTrain(gc, t, viewScale);
        }

        gc.restore();

        // 3. EFEITOS VISUAIS GLOBAIS
        if (isPausedByConflict) {
            double alpha = 0.1 + 0.1 * Math.sin(System.currentTimeMillis() / 100.0);
            gc.setFill(Color.rgb(255, 0, 0, Math.max(0, alpha)));
            gc.fillRect(0, 0, w, h);

            gc.setFill(Color.WHITE);
            gc.setFont(Font.font("Arial", FontWeight.BOLD, 40));
            gc.setTextAlign(TextAlignment.CENTER);
            gc.fillText("‚ö† CONFLITO DETETADO ‚ö†", w/2, h/2 - 60);
        }

        // 4. UI (OVERLAY) - DESENHA POR CIMA DE TUDO
        drawHUD(gc, w, h);
        drawNotifications(gc, w, h);
    }

    private void drawStation(GraphicsContext gc, String name, Point2D pos, double viewScale, Set<String> drawn) {
        if (drawn.contains(name)) return;
        drawn.add(name);

        double radius = 5.0 * viewScale;
        gc.setFill(Color.WHITE);
        gc.fillOval(pos.getX() - radius/2, pos.getY() - radius/2, radius, radius);

        // Nome da Esta√ß√£o com Fundo (Para n√£o misturar com linhas)
        if (scale > 0.4 || isPausedByConflict) {
            gc.setFont(Font.font("Arial", FontWeight.NORMAL, 11 * viewScale));

            // Fundo do texto
            String text = name;
            double tw = text.length() * 6 * viewScale; // Estimativa
            double th = 12 * viewScale;

            gc.setFill(Color.rgb(30, 30, 30, 0.7)); // Caixa escura
            gc.fillRoundRect(pos.getX() + radius + 2, pos.getY() - th/2 + 2, tw, th, 5, 5);

            gc.setFill(Color.LIGHTGRAY);
            gc.setTextAlign(TextAlignment.LEFT);
            gc.fillText(name, pos.getX() + radius + 4, pos.getY() + radius/2);
        }
    }

    private void drawTrain(GraphicsContext gc, VisualTrain t, double viewScale) {
        Point2D pos = t.getCurrentPositionOrLastStation(simulationTime);
        if (pos == null) return;

        boolean waiting = t.isWaiting(simulationTime);
        double radius = 10.0 * viewScale;

        if (waiting || t == conflictFocusTrain) {
            double pulseSize = radius * (1.5 + 0.8 * Math.sin(System.currentTimeMillis() / 150.0));
            gc.setStroke(Color.RED);
            gc.setLineWidth(3 * viewScale);
            gc.strokeOval(pos.getX() - pulseSize/2, pos.getY() - pulseSize/2, pulseSize, pulseSize);
        }

        gc.setFill(waiting ? Color.RED : Color.LIME);
        gc.setEffect(new javafx.scene.effect.DropShadow(10 * viewScale, waiting ? Color.RED : Color.LIME));
        gc.fillOval(pos.getX() - radius/2, pos.getY() - radius/2, radius, radius);
        gc.setEffect(null);

        gc.setFill(Color.WHITE);
        gc.setFont(Font.font("Arial", FontWeight.BOLD, 12 * viewScale));
        String label = t.train.getTrainId();
        if (waiting) label = "‚ö† " + label;

        // Fundo do Label do Comboio
        double tw = label.length() * 7 * viewScale;
        gc.setFill(Color.rgb(0,0,0,0.8));
        gc.fillRoundRect(pos.getX() + radius, pos.getY() - radius, tw, 14*viewScale, 5,5);

        gc.setFill(Color.WHITE);
        gc.fillText(label, pos.getX() + radius + 2, pos.getY());
    }

    // --- CORRE√á√ÉO DA UI: MOVIDA PARA A DIREITA ---
    private void drawHUD(GraphicsContext gc, double w, double h) {
        double hudW = 260;
        double hudH = 90;
        double hudX = w - hudW - 20; // Canto Superior Direito
        double hudY = 20;

        // Caixa
        gc.setFill(Color.rgb(0,0,0,0.85));
        gc.fillRoundRect(hudX, hudY, hudW, hudH, 10, 10);
        gc.setStroke(Color.WHITE);
        gc.setLineWidth(1);
        gc.strokeRoundRect(hudX, hudY, hudW, hudH, 10, 10);

        // Hora
        gc.setFill(Color.WHITE);
        gc.setFont(Font.font("Monospaced", FontWeight.BOLD, 22));
        String time = (simulationTime != null) ? simulationTime.format(DateTimeFormatter.ofPattern("HH:mm:ss")) : "--:--:--";
        gc.setTextAlign(TextAlignment.LEFT);
        gc.fillText("üïí " + time, hudX + 15, hudY + 30);

        // Status
        String status = isPausedByConflict ? "PAUSADO (CONFLITO)" : (isSkippingTime ? "‚è© AVAN√áANDO" : "EM CURSO");
        gc.setFill(isPausedByConflict ? Color.RED : (isSkippingTime ? Color.CYAN : Color.LIME));
        gc.setFont(Font.font("Arial", FontWeight.BOLD, 13));
        gc.fillText(status, hudX + 15, hudY + 55);

        // Info
        gc.setFill(Color.LIGHTGRAY);
        gc.setFont(Font.font("Arial", 11));
        gc.fillText(String.format("Zoom: %.1fx | Speed: %.0f", scale, speedFactor), hudX + 15, hudY + 75);
    }

    // --- NOTIFICA√á√ïES NO CANTO INFERIOR ESQUERDO ---
    private void drawNotifications(GraphicsContext gc, double w, double h) {
        double nW = 350;
        double startX = 20;
        double startY = h - 60; // Come√ßa de baixo

        for (GameNotification n : notifications) {
            gc.setFill(Color.rgb(30, 30, 30, 0.9));
            gc.fillRoundRect(startX, startY, nW, 35, 8, 8);
            gc.setStroke(Color.GRAY);
            gc.setLineWidth(0.5);
            gc.strokeRoundRect(startX, startY, nW, 35, 8, 8);

            gc.setFill(Color.WHITE);
            gc.setFont(Font.font("Arial", 14));
            gc.setTextAlign(TextAlignment.LEFT);
            gc.fillText(n.message, startX + 10, startY + 23);

            startY -= 40; // Empilha para cima
        }
    }

    private static class VisualSegment {
        String start, end;
        Point2D p1, p2;
        boolean isDouble;
        VisualSegment(String s, String e, Point2D p1, Point2D p2, boolean d) {
            this.start = s; this.end = e; this.p1 = p1; this.p2 = p2; this.isDouble = d;
        }
        boolean matches(String s, String e) {
            return (start.equals(s) && end.equals(e)) || (start.equals(e) && end.equals(s));
        }
    }

    private static class VisualTrain {
        Train train;
        String destination = "?";
        List<Movement> movements = new ArrayList<>();
        boolean notifiedStart = false;

        VisualTrain(Train t) { this.train = t; }

        void addMovement(LocalTime s, LocalTime e, Point2D p1, Point2D p2) {
            movements.add(new Movement(s, e, p1, p2));
            movements.sort(Comparator.comparing(m -> m.start));
        }

        boolean isWaiting(LocalTime now) {
            if (now == null || movements.isEmpty()) return false;
            if (now.isAfter(movements.get(0).start) && now.isBefore(movements.get(movements.size()-1).end)) {
                for (Movement m : movements) {
                    if (!now.isBefore(m.start) && !now.isAfter(m.end)) return false;
                }
                return true;
            }
            return false;
        }

        boolean isActive(LocalTime now) {
            return getCurrentPositionOrLastStation(now) != null && !isWaiting(now);
        }

        boolean isAboutToStart(LocalTime now, int minutes) {
            if (now == null || movements.isEmpty()) return false;
            long diff = ChronoUnit.MINUTES.between(now, movements.get(0).start);
            return diff >= 0 && diff <= minutes;
        }

        Point2D getCurrentPositionOrLastStation(LocalTime now) {
            if (now == null || movements.isEmpty()) return null;
            for (Movement m : movements) {
                if (!now.isBefore(m.start) && !now.isAfter(m.end)) {
                    long total = Duration.between(m.start, m.end).getSeconds();
                    long current = Duration.between(m.start, now).getSeconds();
                    if (total <= 0) total = 1;
                    double t = (double) current / total;
                    return new Point2D(m.p1.getX() + (m.p2.getX() - m.p1.getX()) * t, m.p1.getY() + (m.p2.getY() - m.p1.getY()) * t);
                }
            }
            for (int i = 0; i < movements.size() - 1; i++) {
                if (now.isAfter(movements.get(i).end) && now.isBefore(movements.get(i+1).start)) {
                    return movements.get(i).p2;
                }
            }
            return null;
        }
    }

    private static class Movement {
        LocalTime start, end;
        Point2D p1, p2;
        Movement(LocalTime s, LocalTime e, Point2D p1, Point2D p2) {
            this.start = s; this.end = e; this.p1 = p1; this.p2 = p2;
        }
    }

    private static class GameNotification {
        String message;
        long expireTime;
        GameNotification(String m, long e) { this.message = m; this.expireTime = e; }
    }
}