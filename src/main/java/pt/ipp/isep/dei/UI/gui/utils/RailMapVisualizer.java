package pt.ipp.isep.dei.UI.gui.utils;

import javafx.animation.AnimationTimer;
import javafx.animation.FadeTransition;
import javafx.animation.ScaleTransition;
import javafx.geometry.Insets;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.ToggleButton;
import javafx.scene.effect.DropShadow;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.util.Duration;
import pt.ipp.isep.dei.domain.Train;

import java.text.Normalizer;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.regex.Pattern;

public class RailMapVisualizer extends StackPane {

    // --- COMPONENTES UI ---
    private final Canvas canvas;
    private final Pane canvasPane;
    private final VBox notificationPanel;
    private VBox notificationContent;
    private Button notificationToggle; // Bot√£o pequeno

    // Pain√©is de Aviso
    private final VBox conflictPanel;
    private final VBox successPanel;

    // --- DADOS ---
    private final Map<String, Point2D> stationCoordinates = new HashMap<>();
    private final Map<String, Point2D> autoGeneratedCoordinates = new HashMap<>();
    private final List<VisualSegment> segments = new ArrayList<>();
    private final List<VisualTrain> allTrains = new ArrayList<>();
    private final Map<String, ConflictInfo> conflictRegistry = new HashMap<>();

    // --- C√ÇMARA ---
    private double scale = 0.6; // Zoom inicial um pouco maior j√° que o mapa encolheu
    private double translateX = 0, translateY = 0;
    private double targetScale = 0.6;
    private double targetTranslateX = 0, targetTranslateY = 0;
    private boolean autoCameraMode = true;
    private double lastMouseX, lastMouseY;

    // --- SIMULA√á√ÉO ---
    private LocalTime simulationTime;
    private LocalTime maxSimulationTime;
    private double speedFactor = 50.0;
    private double userSpeedSetting = 50.0;
    private AnimationTimer timer;
    private boolean isFinished = false;

    // --- ESTADO CR√çTICO ---
    private boolean isPausedByConflict = false;
    private boolean isSlowMotionReplay = false;
    private VisualTrain conflictFocusTrain = null;
    private long slowMotionEndTime = 0;

    // --- CONTROLOS ---
    private final Button btnZoomIn, btnZoomOut;
    private final ToggleButton btnAutoCam;
    private final Label clockLabel;

    public RailMapVisualizer() {
        this.setStyle("-fx-background-color: #0b1120;");

        // 1. Layer Mapa
        this.canvasPane = new Pane();
        this.canvas = new Canvas(2000, 3000);
        this.canvasPane.getChildren().add(canvas);
        canvas.widthProperty().bind(this.widthProperty());
        canvas.heightProperty().bind(this.heightProperty());

        setupGeographicallyAccurateMap(); // MAPA COMPACTADO

        // 2. Layer HUD (Log Minimalista)
        this.notificationPanel = createNotificationPanel();

        // 3. Layer Rel√≥gio
        this.clockLabel = new Label("00:00:00");
        this.clockLabel.setStyle("-fx-text-fill: white; -fx-font-family: 'Monospaced'; -fx-font-size: 28px; -fx-font-weight: bold; -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.8), 5, 0, 0, 1);");

        // 4. Layer Controlos
        this.btnZoomIn = createGlassButton("+");
        this.btnZoomIn.setOnAction(e -> manualZoom(1.2));
        this.btnZoomOut = createGlassButton("-");
        this.btnZoomOut.setOnAction(e -> manualZoom(0.8));

        this.btnAutoCam = new ToggleButton("AUTO CAM");
        this.btnAutoCam.setSelected(true);
        this.btnAutoCam.setStyle("-fx-background-color: rgba(16, 185, 129, 0.2); -fx-text-fill: #10b981; -fx-font-weight: bold; -fx-border-color: rgba(16, 185, 129, 0.4); -fx-border-radius: 5;");
        this.btnAutoCam.selectedProperty().addListener((obs, old, isSelected) -> autoCameraMode = isSelected);

        HBox controlsBox = new HBox(10, btnAutoCam, btnZoomOut, btnZoomIn);
        controlsBox.setAlignment(Pos.TOP_RIGHT);
        controlsBox.setPadding(new Insets(20));
        controlsBox.setPickOnBounds(false);

        // 5. Layer Modais
        this.conflictPanel = createConflictPanel();
        this.successPanel = createSuccessPanel();

        this.getChildren().addAll(canvasPane, clockLabel, notificationPanel, controlsBox, conflictPanel, successPanel);

        // --- POSICIONAMENTO ---
        StackPane.setAlignment(clockLabel, Pos.TOP_CENTER);
        StackPane.setMargin(clockLabel, new Insets(25, 0, 0, 0));

        // LOG: Canto Superior Esquerdo, mas pequeno
        StackPane.setAlignment(notificationPanel, Pos.TOP_LEFT);
        StackPane.setMargin(notificationPanel, new Insets(20, 0, 0, 20));

        StackPane.setAlignment(controlsBox, Pos.TOP_RIGHT);
        StackPane.setAlignment(conflictPanel, Pos.CENTER);
        StackPane.setAlignment(successPanel, Pos.CENTER);

        setupInteraction();
    }

    // --- PAINEL DE LOG MINIMALISTA ---
    private VBox createNotificationPanel() {
        VBox container = new VBox(5);
        container.setMaxWidth(250);
        container.setPickOnBounds(false); // Permite clicar atrav√©s das √°reas vazias

        // Bot√£o Toggle Pequeno e Discreto
        notificationToggle = new Button("üìÑ LOG");
        notificationToggle.setFont(Font.font("System", FontWeight.BOLD, 10));
        // Estilo: Pequeno, fundo escuro semi-transparente, borda subtil
        notificationToggle.setStyle(
                "-fx-background-color: rgba(30, 41, 59, 0.8); " +
                        "-fx-text-fill: #94a3b8; " +
                        "-fx-background-radius: 4; " +
                        "-fx-border-color: #475569; " +
                        "-fx-border-radius: 4; " +
                        "-fx-cursor: hand; " +
                        "-fx-padding: 4 8;"
        );

        // √Årea de Conte√∫do (Escondida por defeito)
        notificationContent = new VBox(5);
        notificationContent.setPadding(new Insets(8));
        notificationContent.setStyle("-fx-background-color: rgba(15, 23, 42, 0.95); -fx-background-radius: 4; -fx-border-color: #475569; -fx-border-width: 1;");

        ScrollPane scroll = new ScrollPane(notificationContent);
        scroll.setFitToWidth(true);
        scroll.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        scroll.setStyle("-fx-background: transparent; -fx-background-color: transparent;");
        scroll.setMaxHeight(200);

        // Wrapper para controlar visibilidade
        VBox contentWrapper = new VBox(scroll);
        contentWrapper.setVisible(false);
        contentWrapper.setManaged(false); // N√£o ocupa espa√ßo quando invis√≠vel

        // A√ß√£o do Bot√£o
        notificationToggle.setOnAction(e -> {
            boolean isVisible = contentWrapper.isVisible();
            contentWrapper.setVisible(!isVisible);
            contentWrapper.setManaged(!isVisible);

            if (!isVisible) {
                notificationToggle.setStyle("-fx-background-color: #10b981; -fx-text-fill: white; -fx-background-radius: 4; -fx-padding: 4 8;");
                notificationToggle.setText("‚úñ FECHAR");
            } else {
                notificationToggle.setStyle("-fx-background-color: rgba(30, 41, 59, 0.8); -fx-text-fill: #94a3b8; -fx-background-radius: 4; -fx-border-color: #475569; -fx-border-radius: 4; -fx-padding: 4 8;");
                notificationToggle.setText("üìÑ LOG");
            }
        });

        container.getChildren().addAll(notificationToggle, contentWrapper);
        return container;
    }

    // --- MAPA COMPACTADO (Corre√ß√£o de Velocidade Visual) ---
    private void setupGeographicallyAccurateMap() {
        // Reduzi as dist√¢ncias verticais (Y) para evitar "linhas gigantes" onde o comboio parece voar.
        // O mapa fica mais "apertado" verticalmente.

        // --- LINHA DO MINHO ---
        addStation("Valenca", 300, 100);
        addStation("Sao Pedro da Torre", 305, 150); // Encurtado
        addStation("Vila Nova de Cerveira", 290, 210);
        addStation("Caminha", 280, 270);
        addStation("Ancora Praia", 280, 320);
        addStation("Afife", 280, 360);
        addStation("Viana do Castelo", 280, 420); // Reduzido de 550 para 420

        addStation("Barcelos", 350, 520);
        addStation("Nine", 400, 600); // Reduzido de 780 para 600

        // Ramal de Braga
        addStation("Tadim", 450, 580);
        addStation("Braga", 500, 570);

        // Descendo para Porto (Compactado)
        addStation("Famalicao", 400, 650);
        addStation("Trofa", 400, 700);

        // Ramal Guimar√£es
        addStation("Santo Tirso", 450, 690);
        addStation("Vizela", 500, 680);
        addStation("Guimaraes", 550, 670);

        // --- GRANDE PORTO (Compactado) ---
        addStation("Ermesinde", 420, 760);
        addStation("Rio Tinto", 410, 800);
        addStation("Contumil", 400, 840);

        // Porto Central
        addStation("Porto Campanha", 380, 900); // Era 1200, agora 900. Muito mais perto.
        addStation("Porto Sao Bento", 340, 930);

        // --- LINHA DO DOURO ---
        addStation("Valongo", 460, 770);
        addStation("Paredes", 520, 780);
        addStation("Penafiel", 580, 790);
        addStation("Caide", 650, 800);
        addStation("Marco de Canaveses", 750, 820);
        addStation("Regua", 900, 850);
        addStation("Pinhao", 1000, 860);
        addStation("Pocinho", 1200, 870);

        // --- SUL DO PORTO ---
        addStation("General Torres", 380, 960);
        addStation("Vila Nova de Gaia", 380, 1000);
        addStation("Granja", 370, 1060);
        addStation("Espinho", 360, 1120);
        addStation("Esmoriz", 360, 1180);
        addStation("Ovar", 355, 1260);
        addStation("Estarreja", 350, 1340);
        addStation("Aveiro", 340, 1450);

        addStation("Mealhada", 360, 1550);
        addStation("Pampilhosa", 370, 1620);
        addStation("Coimbra B", 370, 1700);
        addStation("Coimbra", 400, 1720);

        addStation("Alfarelos", 350, 1780);
        addStation("Pombal", 360, 1900);
        addStation("Entroncamento", 380, 2100);
        addStation("Lisboa Oriente", 300, 2400);
        addStation("Lisboa Santa Apolonia", 280, 2480);

        // --- LINHA DA BEIRA ALTA ---
        addStation("Mortagua", 450, 1640);
        addStation("Santa Comba Dao", 520, 1660);
        addStation("Mangualde", 600, 1680);
        addStation("Guarda", 800, 1660);
        addStation("Vilar Formoso", 950, 1680);
    }

    // --- PAINEL DE SUCESSO ---
    private VBox createSuccessPanel() {
        VBox panel = new VBox(15);
        panel.setAlignment(Pos.CENTER);
        panel.setMaxSize(500, 320);
        panel.setStyle("-fx-background-color: rgba(6, 78, 59, 0.95); -fx-background-radius: 15; -fx-border-color: #10b981; -fx-border-width: 3; -fx-effect: dropshadow(three-pass-box, rgba(16, 185, 129, 0.4), 50, 0, 0, 0);");

        Label icon = new Label("‚úî SUCESSO");
        icon.setStyle("-fx-text-fill: #10b981; -fx-font-size: 32px; -fx-font-weight: bold; -fx-effect: dropshadow(gaussian, black, 2, 1, 0, 0);");

        Label title = new Label("SIMULA√á√ÉO TERMINADA");
        title.setStyle("-fx-text-fill: white; -fx-font-size: 22px; -fx-font-weight: bold;");

        Label desc = new Label("Todos os conflitos foram resolvidos e os hor√°rios cumpridos.");
        desc.setStyle("-fx-text-fill: #d1fae5; -fx-font-size: 16px; -fx-text-alignment: center;");
        desc.setWrapText(true);

        Button btnRestart = new Button("FECHAR / REINICIAR");
        btnRestart.setStyle("-fx-background-color: #10b981; -fx-text-fill: white; -fx-font-weight: bold; -fx-padding: 12 30; -fx-background-radius: 8; -fx-cursor: hand; -fx-font-size: 14px;");
        btnRestart.setOnAction(e -> panel.setVisible(false));

        panel.getChildren().addAll(icon, title, desc, btnRestart);
        panel.setVisible(false);
        return panel;
    }

    private void showSuccessPanel() {
        if (!successPanel.isVisible()) {
            successPanel.setVisible(true);
            successPanel.toFront();
            ScaleTransition st = new ScaleTransition(Duration.millis(500), successPanel);
            st.setFromX(0.5); st.setFromY(0.5); st.setToX(1.0); st.setToY(1.0); st.play();
        }
    }

    // --- (Resto do c√≥digo de l√≥gica de simula√ß√£o e desenho mantido igual) ---

    public void addLog(String msg, boolean isCritical) {
        Label lbl = new Label((isCritical ? "‚ö† " : "‚û§ ") + msg);
        lbl.setWrapText(true);
        lbl.setMaxWidth(220);
        lbl.setFont(Font.font("Segoe UI", FontWeight.NORMAL, 11));

        if (isCritical) {
            lbl.setStyle("-fx-text-fill: #ff6b6b; -fx-font-weight: bold; -fx-background-color: rgba(255,0,0,0.15); -fx-padding: 3; -fx-background-radius: 3;");
        } else {
            lbl.setStyle("-fx-text-fill: #cbd5e1; -fx-padding: 2;");
        }
        notificationContent.getChildren().add(0, lbl);
        if (notificationContent.getChildren().size() > 30) notificationContent.getChildren().remove(30, notificationContent.getChildren().size());
    }

    private Point2D getCoordinates(String name) {
        String key = normalize(name);
        if (stationCoordinates.containsKey(key)) return stationCoordinates.get(key);
        for (String k : stationCoordinates.keySet()) if (k.contains(key) || key.contains(k)) return stationCoordinates.get(k);
        if (!autoGeneratedCoordinates.containsKey(key)) {
            double autoX = 150;
            double autoY = 400 + (autoGeneratedCoordinates.size() * 30);
            autoGeneratedCoordinates.put(key, new Point2D(autoX, autoY));
        }
        return autoGeneratedCoordinates.get(key);
    }

    private String normalize(String s) {
        if (s == null) return "";
        String temp = Normalizer.normalize(s, Normalizer.Form.NFD);
        Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+");
        return pattern.matcher(temp).replaceAll("").toLowerCase().trim()
                .replace(" - ", " ").replace("-", " ")
                .replace("√ß", "c").replace("√£", "a").replace("√µ", "o").replace("√©", "e")
                .replace("√≠", "i").replace("√°", "a").replace("√¢", "a");
    }

    private void addStation(String name, double x, double y) {
        stationCoordinates.put(normalize(name), new Point2D(x, y));
    }

    private Button createGlassButton(String text) {
        Button btn = new Button(text);
        btn.setStyle("-fx-background-color: rgba(255, 255, 255, 0.1); -fx-text-fill: white; -fx-font-weight: bold; -fx-min-width: 30px; -fx-background-radius: 5; -fx-border-color: rgba(255,255,255,0.2);");
        return btn;
    }

    private VBox createConflictPanel() {
        VBox panel = new VBox(15);
        panel.setAlignment(Pos.CENTER);
        panel.setMaxSize(480, 300);
        panel.setStyle("-fx-background-color: rgba(15, 23, 42, 0.98); -fx-background-radius: 15; -fx-border-color: #ef4444; -fx-border-width: 3; -fx-effect: dropshadow(three-pass-box, rgba(239, 68, 68, 0.6), 80, 0, 0, 0);");

        Label icon = new Label("‚ö† COLIS√ÉO EVITADA");
        icon.setStyle("-fx-text-fill: #ef4444; -fx-font-size: 26px; -fx-font-weight: bold;");

        Label desc = new Label("Sistemas de seguran√ßa ativados.");
        desc.setId("conflictDesc");
        desc.setStyle("-fx-text-fill: #cbd5e1; -fx-font-size: 16px; -fx-text-alignment: center;");
        desc.setWrapText(true);

        Button btn = new Button("VISUALIZAR A√á√ÉO (Retomar)");
        btn.setStyle("-fx-background-color: white; -fx-text-fill: #0f172a; -fx-font-weight: bold; -fx-padding: 12 25; -fx-background-radius: 20; -fx-cursor: hand; -fx-font-size: 14px;");

        btn.setOnAction(e -> {
            panel.setVisible(false);
            isPausedByConflict = false;
            isSlowMotionReplay = true;
            speedFactor = 1.0;
            slowMotionEndTime = System.currentTimeMillis() + 3000;
            addLog("‚ñ∂ Retomando tr√°fego...", false);
        });

        panel.getChildren().addAll(icon, desc, btn);
        panel.setVisible(false);
        return panel;
    }

    public void loadSchedule(Map<Train, List<String>> trainSchedules, LocalTime time) {
        segments.clear();
        allTrains.clear();
        conflictRegistry.clear();
        notificationContent.getChildren().clear();
        conflictPanel.setVisible(false);
        successPanel.setVisible(false);
        isFinished = false;

        LocalTime minT = LocalTime.MAX;
        LocalTime maxT = LocalTime.MIN;

        for (List<String> logs : trainSchedules.values()) {
            for (String line : logs) {
                if (line.startsWith("!!!CONFLICT")) {
                    String[] parts = line.split("\\|");
                    if (parts.length >= 4) {
                        conflictRegistry.put(parts[1], new ConflictInfo(parts[2], Integer.parseInt(parts[3])));
                    }
                }
            }
        }

        for (Map.Entry<Train, List<String>> entry : trainSchedules.entrySet()) {
            Train train = entry.getKey();
            VisualTrain vt = new VisualTrain(train);
            boolean hasData = false;

            for (String logLine : entry.getValue()) {
                if (logLine.startsWith("!!!")) continue;
                String[] parts = logLine.split("\\|");
                if (parts.length < 7) continue;

                try {
                    String startSt = parts[1].trim();
                    String endSt = parts[2].trim();
                    if (parts[5].trim().equals("N/A") || parts[6].trim().equals("N/A")) continue;

                    LocalTime in = LocalTime.parse(parts[5].trim());
                    LocalTime out = LocalTime.parse(parts[6].trim());

                    if (in.isBefore(minT)) minT = in;
                    if (out.isAfter(maxT)) maxT = out;

                    Point2D p1 = getCoordinates(startSt);
                    Point2D p2 = getCoordinates(endSt);

                    if (segments.stream().noneMatch(s -> s.matches(startSt, endSt))) {
                        boolean isDouble = parts[3].toLowerCase().contains("double");
                        segments.add(new VisualSegment(startSt, endSt, p1, p2, isDouble));
                    }
                    vt.addMovement(in, out, p1, p2, startSt, endSt);
                    hasData = true;
                } catch (Exception e) {}
            }

            if (hasData) {
                ConflictInfo c = conflictRegistry.get(train.getTrainId());
                if (c != null && !vt.movements.isEmpty()) {
                    vt.initialDelayMinutes = c.delayMinutes;
                    vt.hasInitialConflict = true;
                    vt.scheduledStart = vt.movements.get(0).start.minusMinutes(c.delayMinutes);
                }
                allTrains.add(vt);
            }
        }

        this.simulationTime = (minT == LocalTime.MAX) ? LocalTime.of(8, 0) : minT.minusMinutes(30);
        this.maxSimulationTime = maxT.plusMinutes(30);

        autoCameraMode = true;
        btnAutoCam.setSelected(true);
        scale = 0.6; // Ajuste de zoom inicial
        updateFrame();
        addLog("Rede carregada.", false);
    }

    public void startAnimation() {
        if (timer != null) timer.stop();
        if (allTrains.isEmpty()) return;

        timer = new AnimationTimer() {
            private long lastUpdate = 0;
            @Override
            public void handle(long now) {
                if (lastUpdate == 0) { lastUpdate = now; return; }
                double elapsed = (now - lastUpdate) / 1_000_000_000.0;
                lastUpdate = now;

                if (simulationTime != null && !isFinished) {
                    if (isSlowMotionReplay && System.currentTimeMillis() > slowMotionEndTime) {
                        isSlowMotionReplay = false;
                        speedFactor = userSpeedSetting;
                        conflictFocusTrain = null;
                        addLog("Velocidade normalizada.", false);
                    }
                    checkDepartures();
                    if (!isPausedByConflict && !isSlowMotionReplay) checkForConflicts();
                    if (!isPausedByConflict) {
                        if (simulationTime.isAfter(maxSimulationTime)) {
                            isFinished = true;
                            addLog("Fim da Simula√ß√£o.", false);
                            showSuccessPanel();
                        } else {
                            simulationTime = simulationTime.plusSeconds((long) (elapsed * speedFactor));
                        }
                    }
                }
                updateCameraLogic();
                applyCameraSmoothing();
                updateFrame();
            }
        };
        timer.start();
    }

    private void checkDepartures() {
        for (VisualTrain vt : allTrains) {
            if (vt.movements.isEmpty()) continue;
            LocalTime ref = (vt.scheduledStart != null) ? vt.scheduledStart : vt.movements.get(0).start;
            long minToStart = ChronoUnit.MINUTES.between(simulationTime, ref);
            if (minToStart >= 0 && minToStart <= 10 && !vt.notifiedStart) {
                addLog("Partida: " + vt.train.getTrainId() + " (" + minToStart + " min)", false);
                vt.notifiedStart = true;
            }
        }
    }

    private void checkForConflicts() {
        for (VisualTrain vt : allTrains) {
            if (vt.hasInitialConflict && !simulationTime.isBefore(vt.scheduledStart) && simulationTime.isBefore(vt.movements.get(0).start) && !vt.isWaitNotified) {
                triggerConflictPause(vt, "Atraso (" + vt.initialDelayMinutes + " min) - Aguarda via livre");
                vt.isWaitNotified = true;
                break;
            }
            if (vt.isWaitingBetweenStations(simulationTime) && !vt.isWaitNotified) {
                triggerConflictPause(vt, "Cruzamento de linhas / Gest√£o Tr√°fego");
                vt.isWaitNotified = true;
                break;
            }
            if (!vt.hasInitialConflict && !vt.isWaitingBetweenStations(simulationTime)) vt.isWaitNotified = false;
        }
    }

    private void triggerConflictPause(VisualTrain t, String reason) {
        if (isPausedByConflict) return;
        isPausedByConflict = true;
        conflictFocusTrain = t;
        speedFactor = 0;
        Label desc = (Label) conflictPanel.lookup("#conflictDesc");
        if(desc != null) desc.setText("COMBOIO: " + t.train.getTrainId() + "\nLOCAL: " + t.getCurrentLocationName(simulationTime) + "\nMOTIVO: " + reason);
        addLog("‚ö† CONFLITO: " + t.train.getTrainId(), true);
        conflictPanel.setVisible(true);
        conflictPanel.toFront();
        autoCameraMode = false;
    }

    private void updateFrame() {
        GraphicsContext gc = canvas.getGraphicsContext2D();
        double w = getWidth(); double h = getHeight();
        gc.setFill(Color.web("#0b1120"));
        gc.fillRect(0, 0, w, h);
        gc.save();
        gc.translate(translateX, translateY);
        gc.scale(scale, scale);
        double viewScale = 1.0 / Math.max(0.2, scale);

        gc.setLineCap(javafx.scene.shape.StrokeLineCap.ROUND);
        for (VisualSegment s : segments) {
            double width = (s.isDouble ? 3.0 : 1.5) * viewScale;
            gc.setStroke(Color.rgb(255,255,255,0.1));
            gc.setLineWidth(width + 2);
            gc.strokeLine(s.p1.getX(), s.p1.getY(), s.p2.getX(), s.p2.getY());
            Color c = s.isDouble ? Color.web("#3b82f6") : Color.web("#f59e0b");
            if (isPausedByConflict) c = c.darker().desaturate();
            gc.setStroke(c);
            gc.setLineWidth(width);
            gc.strokeLine(s.p1.getX(), s.p1.getY(), s.p2.getX(), s.p2.getY());
        }

        Set<String> drawn = new HashSet<>();
        for (VisualSegment s : segments) {
            drawStation(gc, s.origName, s.p1, viewScale, drawn);
            drawStation(gc, s.destName, s.p2, viewScale, drawn);
        }
        for (VisualTrain t : allTrains) drawTrain(gc, t, viewScale);
        gc.restore();
        if (simulationTime != null) clockLabel.setText(simulationTime.format(DateTimeFormatter.ofPattern("HH:mm:ss")));
    }

    private void drawStation(GraphicsContext gc, String name, Point2D pos, double vs, Set<String> drawn) {
        if (drawn.contains(name)) return;
        drawn.add(name);
        double r = 2.5 * vs;
        gc.setFill(Color.WHITE);
        gc.fillOval(pos.getX() - r, pos.getY() - r, r*2, r*2);
        if (scale > 0.3) {
            gc.setFont(Font.font("Arial", 9 * vs));
            gc.setFill(Color.web("#94a3b8"));
            gc.fillText(name, pos.getX() + r + 4, pos.getY() + 3*vs);
        }
    }

    private void drawTrain(GraphicsContext gc, VisualTrain t, double vs) {
        Point2D p = t.getPosition(simulationTime);
        if (p == null) return;
        boolean waiting = t.isWaitingOrDelayed(simulationTime);
        boolean isFocus = (t == conflictFocusTrain);
        if (isPausedByConflict && !isFocus) gc.setGlobalAlpha(0.2);
        double r = (isFocus ? 10.0 : 6.0) * vs;
        Color c = waiting ? Color.web("#ef4444") : Color.web("#10b981");
        if (waiting || isFocus) {
            double pulse = r * (1.2 + 0.2 * Math.sin(System.currentTimeMillis() / 100.0));
            gc.setStroke(Color.web("#ef4444", 0.7));
            gc.setLineWidth(1.5 * vs);
            gc.strokeOval(p.getX() - pulse, p.getY() - pulse, pulse*2, pulse*2);
        }
        gc.setFill(c);
        gc.setEffect(new DropShadow(5 * vs, c));
        gc.fillOval(p.getX() - r, p.getY() - r, r*2, r*2);
        gc.setEffect(null);
        if (scale > 0.4 || isFocus || waiting) {
            gc.setFill(Color.WHITE);
            gc.setFont(Font.font("Arial", FontWeight.BOLD, 9 * vs));
            gc.fillText(t.train.getTrainId(), p.getX() + r + 2, p.getY() - r);
        }
        gc.setGlobalAlpha(1.0);
    }

    private void updateCameraLogic() {
        if (conflictFocusTrain != null && isPausedByConflict) {
            Point2D p = conflictFocusTrain.getPosition(simulationTime);
            if(p != null) {
                targetScale = 2.0;
                targetTranslateX = (getWidth()/2.0) - (p.getX() * targetScale);
                targetTranslateY = (getHeight()/2.0) - (p.getY() * targetScale);
                applyCameraSmoothing();
            }
            return;
        }
        if (!autoCameraMode) return;
        double sumX = 0, sumY = 0;
        int count = 0;
        double minX = Double.MAX_VALUE, maxX = -Double.MAX_VALUE;
        double minY = Double.MAX_VALUE, maxY = -Double.MAX_VALUE;
        if (simulationTime != null) {
            for (VisualTrain vt : allTrains) {
                if (vt.isActive(simulationTime) || vt.hasInitialConflict) {
                    Point2D p = vt.getPosition(simulationTime);
                    if (p != null) {
                        sumX += p.getX(); sumY += p.getY();
                        minX = Math.min(minX, p.getX()); maxX = Math.max(maxX, p.getX());
                        minY = Math.min(minY, p.getY()); maxY = Math.max(maxY, p.getY());
                        count++;
                    }
                }
            }
        }
        if (count == 0) return;
        double centerX = sumX / count;
        double centerY = sumY / count;
        if (count == 1) {
            targetScale = 1.5;
        } else {
            double width = Math.max(300, maxX - minX);
            double height = Math.max(300, maxY - minY);
            double scaleX = (getWidth() - 150) / width;
            double scaleY = (getHeight() - 150) / height;
            targetScale = Math.max(0.4, Math.min(Math.min(scaleX, scaleY), 1.5));
        }
        targetTranslateX = (getWidth() / 2.0) - (centerX * targetScale);
        targetTranslateY = (getHeight() / 2.0) - (centerY * targetScale);
        applyCameraSmoothing();
    }

    private void applyCameraSmoothing() {
        double smooth = (isPausedByConflict) ? 0.1 : 0.05;
        scale += (targetScale - scale) * smooth;
        translateX += (targetTranslateX - translateX) * smooth;
        translateY += (targetTranslateY - translateY) * smooth;
    }

    private void setupInteraction() {
        canvasPane.setOnScroll(e -> {
            if (!isPausedByConflict) { autoCameraMode = false; btnAutoCam.setSelected(false); targetScale *= (e.getDeltaY() > 0 ? 1.1 : 0.9); }
        });
        canvasPane.setOnMousePressed(e -> { lastMouseX = e.getX(); lastMouseY = e.getY(); });
        canvasPane.setOnMouseDragged(e -> {
            if (!isPausedByConflict) { autoCameraMode = false; btnAutoCam.setSelected(false); targetTranslateX += (e.getX() - lastMouseX); targetTranslateY += (e.getY() - lastMouseY); lastMouseX = e.getX(); lastMouseY = e.getY(); updateFrame(); }
        });
    }

    public void setSpeedFactor(double f) { userSpeedSetting = f; if(!isSlowMotionReplay && !isPausedByConflict) speedFactor = f; }
    public void stopAnimation() { if(timer != null) timer.stop(); }
    private void manualZoom(double f) { autoCameraMode = false; btnAutoCam.setSelected(false); targetScale *= f; }

    private static class ConflictInfo {
        String station; int delayMinutes;
        ConflictInfo(String s, int d) { this.station = s; this.delayMinutes = d; }
    }
    private static class VisualSegment {
        String origName, destName; Point2D p1, p2; boolean isDouble;
        VisualSegment(String s, String e, Point2D p1, Point2D p2, boolean d) { this.origName = s; this.destName = e; this.p1 = p1; this.p2 = p2; this.isDouble = d; }
        boolean matches(String s, String e) { return (origName.equalsIgnoreCase(s) && destName.equalsIgnoreCase(e)) || (origName.equalsIgnoreCase(e) && destName.equalsIgnoreCase(s)); }
    }
    private static class VisualTrain {
        Train train; List<VisualMovement> movements = new ArrayList<>();
        boolean hasInitialConflict = false; int initialDelayMinutes = 0; LocalTime scheduledStart = null;
        boolean notifiedStart = false; boolean isWaitNotified = false;
        VisualTrain(Train t) { this.train = t; }
        void addMovement(LocalTime s, LocalTime e, Point2D p1, Point2D p2, String st1, String st2) {
            movements.add(new VisualMovement(s, e, p1, p2, st1, st2));
            movements.sort(Comparator.comparing(m -> m.start));
        }
        boolean isWaitingOrDelayed(LocalTime t) {
            if (t == null || movements.isEmpty()) return false;
            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) return true;
            return isWaitingBetweenStations(t);
        }
        boolean isWaitingBetweenStations(LocalTime t) {
            for (int i = 0; i < movements.size() - 1; i++) if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i+1).start)) return true;
            return false;
        }
        boolean isActive(LocalTime t) {
            if (t == null || movements.isEmpty()) return false;
            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) return true;
            for (VisualMovement m : movements) if (!t.isBefore(m.start) && !t.isAfter(m.end)) return true;
            return false;
        }
        Point2D getPosition(LocalTime t) {
            if (t == null || movements.isEmpty()) return null;
            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) {
                if (java.time.Duration.between(t, movements.get(0).start).toMinutes() <= 30) return movements.get(0).p1;
                return null;
            }
            for (VisualMovement m : movements) {
                if (!t.isBefore(m.start) && !t.isAfter(m.end)) {
                    long totalSeconds = java.time.Duration.between(m.start, m.end).getSeconds();
                    long currentSeconds = java.time.Duration.between(m.start, t).getSeconds();
                    double r = (totalSeconds <= 0) ? 1.0 : (double) currentSeconds / totalSeconds;
                    return new Point2D(m.p1.getX() + (m.p2.getX() - m.p1.getX()) * r, m.p1.getY() + (m.p2.getY() - m.p1.getY()) * r);
                }
            }
            for (int i = 0; i < movements.size() - 1; i++) if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i + 1).start)) return movements.get(i).p2;
            if (!movements.isEmpty() && t.isBefore(movements.get(0).start)) {
                LocalTime ref = hasInitialConflict ? scheduledStart : movements.get(0).start;
                if (java.time.Duration.between(t, ref).toMinutes() <= 15) return movements.get(0).p1;
            }
            return null;
        }
        String getCurrentLocationName(LocalTime t) {
            if (t == null || movements.isEmpty()) return "?";
            if (hasInitialConflict && t.isBefore(movements.get(0).start)) return movements.get(0).fromStation;
            for (int i = 0; i < movements.size() - 1; i++) if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i+1).start)) return movements.get(i).destStation;
            return "Em linha";
        }
    }
    private static class VisualMovement {
        LocalTime start, end; Point2D p1, p2; String fromStation, destStation;
        VisualMovement(LocalTime s, LocalTime e, Point2D p1, Point2D p2, String st1, String st2) { this.start = s; this.end = e; this.p1 = p1; this.p2 = p2; this.fromStation = st1; this.destStation = st2; }
    }
}