package pt.ipp.isep.dei.UI.gui.utils;

import javafx.animation.AnimationTimer;
import javafx.animation.FadeTransition;
import javafx.animation.PauseTransition;
import javafx.geometry.Insets;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ToggleButton;
import javafx.scene.effect.DropShadow;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.util.Duration;
import pt.ipp.isep.dei.domain.Train;

import java.text.Normalizer;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.regex.Pattern;

public class RailMapVisualizer extends StackPane {

    // --- UI COMPONENTS ---
    private final Canvas canvas;
    private final Pane canvasPane;
    private final VBox notificationContainer;
    private final VBox conflictPanel;

    // --- DATA ---
    private final Map<String, Point2D> stationCoordinates = new HashMap<>();
    private final Map<String, Point2D> autoGeneratedCoordinates = new HashMap<>();
    private final List<VisualSegment> segments = new ArrayList<>();
    private final List<VisualTrain> allTrains = new ArrayList<>();
    private final Map<String, ConflictInfo> conflictRegistry = new HashMap<>();

    // --- CAMERA ---
    private double scale = 0.5;
    private double translateX = 0, translateY = 0;
    private double targetScale = 0.5;
    private double targetTranslateX = 0, targetTranslateY = 0;
    private boolean autoCameraMode = true;
    private double lastMouseX, lastMouseY;

    // --- SIMULATION STATE ---
    private LocalTime simulationTime;
    private LocalTime maxSimulationTime;
    private double speedFactor = 50.0;
    private double userSpeedSetting = 50.0;
    private AnimationTimer timer;
    private boolean isFinished = false;

    // --- CRITICAL STATE ---
    private boolean isPausedByConflict = false;
    private boolean isSlowMotionReplay = false;
    private VisualTrain conflictFocusTrain = null;
    private long slowMotionEndTime = 0;

    // --- CONTROLS ---
    private final Button btnZoomIn, btnZoomOut;
    private final ToggleButton btnAutoCam;
    private final Label clockLabel;

    public RailMapVisualizer() {
        this.setStyle("-fx-background-color: #0f172a;");

        this.canvasPane = new Pane();
        this.canvas = new Canvas(800, 600);
        this.canvasPane.getChildren().add(canvas);
        canvas.widthProperty().bind(this.widthProperty());
        canvas.heightProperty().bind(this.heightProperty());

        setupRealisticMapCoordinates();

        this.notificationContainer = new VBox(5);
        this.notificationContainer.setPadding(new Insets(20));
        this.notificationContainer.setAlignment(Pos.TOP_LEFT);
        this.notificationContainer.setPickOnBounds(false);
        this.notificationContainer.setMaxHeight(400);

        this.btnZoomIn = createGlassButton("+");
        this.btnZoomIn.setOnAction(e -> manualZoom(1.2));
        this.btnZoomOut = createGlassButton("-");
        this.btnZoomOut.setOnAction(e -> manualZoom(0.8));

        this.btnAutoCam = new ToggleButton("AUTO CAM");
        this.btnAutoCam.setSelected(true);
        this.btnAutoCam.setStyle("-fx-background-color: rgba(16, 185, 129, 0.2); -fx-text-fill: #10b981; -fx-font-weight: bold; -fx-border-color: rgba(16, 185, 129, 0.4); -fx-border-radius: 5; -fx-background-radius: 5;");
        this.btnAutoCam.selectedProperty().addListener((obs, old, isSelected) -> autoCameraMode = isSelected);

        this.clockLabel = new Label("00:00:00");
        this.clockLabel.setStyle("-fx-text-fill: white; -fx-font-family: 'Monospaced'; -fx-font-size: 28px; -fx-font-weight: bold; -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.8), 5, 0, 0, 1);");

        HBox controlsBox = new HBox(10, btnZoomIn, btnZoomOut, btnAutoCam, clockLabel);
        controlsBox.setAlignment(Pos.TOP_RIGHT);
        controlsBox.setPadding(new Insets(20));
        controlsBox.setPickOnBounds(false);

        this.conflictPanel = createConflictPanel();

        this.getChildren().addAll(canvasPane, notificationContainer, controlsBox, conflictPanel);
        StackPane.setAlignment(controlsBox, Pos.TOP_RIGHT);
        StackPane.setAlignment(notificationContainer, Pos.TOP_LEFT);
        StackPane.setAlignment(conflictPanel, Pos.CENTER);

        setupInteraction();
    }

    public void addLog(String msg, boolean isCritical) {
        Label lbl = new Label(msg);
        lbl.setFont(Font.font("Arial", FontWeight.BOLD, 14));
        lbl.setPadding(new Insets(10, 15, 10, 15));
        lbl.setWrapText(true);
        lbl.setMaxWidth(400);

        if (isCritical) {
            lbl.setStyle("-fx-background-color: rgba(220, 38, 38, 0.95); -fx-text-fill: white; -fx-background-radius: 8; -fx-border-color: #ef4444; -fx-border-width: 2; -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.6), 8, 0, 0, 2);");
        } else {
            lbl.setStyle("-fx-background-color: rgba(15, 23, 42, 0.9); -fx-text-fill: #e2e8f0; -fx-background-radius: 6; -fx-border-color: #334155;");
        }

        FadeTransition ftIn = new FadeTransition(Duration.millis(300), lbl);
        ftIn.setFromValue(0); ftIn.setToValue(1);
        ftIn.play();

        if (notificationContainer.getChildren().size() >= 2) {
            notificationContainer.getChildren().remove(1, notificationContainer.getChildren().size());
        }
        notificationContainer.getChildren().add(0, lbl);

        PauseTransition delay = new PauseTransition(Duration.seconds(isCritical ? 10 : 4));
        delay.setOnFinished(e -> {
            FadeTransition ftOut = new FadeTransition(Duration.millis(500), lbl);
            ftOut.setFromValue(1); ftOut.setToValue(0);
            ftOut.setOnFinished(ev -> notificationContainer.getChildren().remove(lbl));
            ftOut.play();
        });
        delay.play();
    }

    private VBox createConflictPanel() {
        VBox panel = new VBox(15);
        panel.setAlignment(Pos.CENTER);
        panel.setMaxSize(450, 280);
        panel.setStyle("-fx-background-color: rgba(15, 23, 42, 0.98); -fx-background-radius: 15; -fx-border-color: #ef4444; -fx-border-width: 2; -fx-effect: dropshadow(three-pass-box, rgba(239, 68, 68, 0.6), 50, 0, 0, 0);");

        Label icon = new Label("⚠ CONFLITO DETETADO");
        icon.setStyle("-fx-text-fill: #ef4444; -fx-font-size: 24px; -fx-font-weight: bold;");

        Label desc = new Label("A aguardar resolução de tráfego...");
        desc.setId("conflictDesc");
        desc.setStyle("-fx-text-fill: #cbd5e1; -fx-font-size: 15px; -fx-text-alignment: center;");
        desc.setWrapText(true);

        Button btn = new Button("VISUALIZAR AÇÃO (Retomar)");
        btn.setStyle("-fx-background-color: white; -fx-text-fill: #0f172a; -fx-font-weight: bold; -fx-padding: 10 20; -fx-background-radius: 20; -fx-cursor: hand; -fx-font-size: 14px;");

        btn.setOnAction(e -> {
            panel.setVisible(false);
            isPausedByConflict = false;
            isSlowMotionReplay = true;
            speedFactor = 1.0;
            slowMotionEndTime = System.currentTimeMillis() + 8000;
            addLog("▶ Retomando em Velocidade Real", false);
        });

        panel.getChildren().addAll(icon, desc, btn);
        panel.setVisible(false);
        return panel;
    }

    private String normalize(String s) {
        if (s == null) return "";
        String temp = Normalizer.normalize(s, Normalizer.Form.NFD);
        Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+");
        return pattern.matcher(temp).replaceAll("").toLowerCase().trim()
                .replace(" - ", " ").replace("-", " ")
                .replace("ç", "c").replace("ã", "a").replace("õ", "o").replace("é", "e");
    }

    private void setupRealisticMapCoordinates() {
        // LINHA DO MINHO (Norte -> Sul)
        addStation("Valenca", 200, 50);
        addStation("Sao Pedro da Torre", 200, 100);
        addStation("Vila Nova de Cerveira", 180, 150);
        addStation("Caminha", 160, 200);
        addStation("Ancora Praia", 150, 250);
        addStation("Afife", 150, 280);
        addStation("Viana do Castelo", 150, 320);
        addStation("Barcelos", 200, 380);
        addStation("Nine", 250, 420);

        // RAMAL DE BRAGA
        addStation("Braga", 350, 380);
        addStation("Tadim", 300, 400);

        // CONTINUAÇÃO LINHA DO MINHO (Nine -> Porto)
        addStation("Famalicao", 250, 460);
        addStation("Trofa", 250, 500);

        // LINHA DE GUIMARÃES
        addStation("Guimaraes", 400, 450);
        addStation("Santo Tirso", 320, 480);

        // ÁREA METROPOLITANA DO PORTO
        addStation("Ermesinde", 260, 550);
        addStation("Rio Tinto", 250, 570);
        addStation("Contumil", 240, 590);
        addStation("Porto Campanha", 220, 620);
        addStation("Porto Sao Bento", 180, 630);

        // LINHA DO NORTE (Gaia -> Sul)
        addStation("Vila Nova de Gaia", 220, 660);
        addStation("Granja", 220, 690);
        addStation("Espinho", 210, 720);
        addStation("Ovar", 200, 800);
        addStation("Aveiro", 180, 900);
        addStation("Coimbra B", 180, 1100);
        addStation("Entroncamento", 150, 1300);
        addStation("Lisboa Oriente", 100, 1500);
        addStation("Lisboa Santa Apolonia", 80, 1550);

        // LINHA DO DOURO (Ermesinde -> Este)
        addStation("Valongo", 300, 550);
        addStation("Paredes", 350, 560);
        addStation("Penafiel", 380, 565);
        addStation("Caide", 420, 570);
        addStation("Marco de Canaveses", 480, 580);
        addStation("Regua", 600, 600);
        addStation("Pinhao", 700, 610);
        addStation("Pocinho", 850, 620);
    }

    private void addStation(String name, double x, double y) {
        stationCoordinates.put(normalize(name), new Point2D(x, y));
    }

    private Point2D getCoordinates(String name) {
        String key = normalize(name);
        if (stationCoordinates.containsKey(key)) return stationCoordinates.get(key);
        for (String k : stationCoordinates.keySet()) {
            if (k.contains(key) || key.contains(k)) return stationCoordinates.get(k);
        }
        if (!autoGeneratedCoordinates.containsKey(key)) {
            autoGeneratedCoordinates.put(key, new Point2D(600, 200 + autoGeneratedCoordinates.size() * 50));
        }
        return autoGeneratedCoordinates.get(key);
    }

    public void loadSchedule(Map<Train, List<String>> trainSchedules, LocalTime time) {
        segments.clear();
        allTrains.clear();
        conflictRegistry.clear();
        notificationContainer.getChildren().clear();
        conflictPanel.setVisible(false);
        isFinished = false;

        LocalTime minT = LocalTime.MAX;
        LocalTime maxT = LocalTime.MIN;

        // 1. CARREGAR CONFLITOS (LÊ TAG !!!CONFLICT)
        for (List<String> logs : trainSchedules.values()) {
            for (String line : logs) {
                if (line.startsWith("!!!CONFLICT")) {
                    String[] parts = line.split("\\|");
                    if (parts.length >= 4) {
                        String trainId = parts[1];
                        String station = parts[2];
                        int delay = Integer.parseInt(parts[3]);
                        conflictRegistry.put(trainId, new ConflictInfo(station, delay));
                    }
                }
            }
        }

        // 2. CARREGAR MOVIMENTOS
        for (Map.Entry<Train, List<String>> entry : trainSchedules.entrySet()) {
            Train train = entry.getKey();
            VisualTrain vt = new VisualTrain(train);
            boolean hasData = false;

            for (String logLine : entry.getValue()) {
                if (logLine.startsWith("!!!")) continue;

                String[] parts = logLine.split("\\|");
                if (parts.length < 7) continue;

                try {
                    String startSt = parts[1].trim();
                    String endSt = parts[2].trim();
                    if (parts[5].trim().equals("N/A") || parts[6].trim().equals("N/A")) continue;

                    LocalTime in = LocalTime.parse(parts[5].trim());
                    LocalTime out = LocalTime.parse(parts[6].trim());

                    if (in.isBefore(minT)) minT = in;
                    if (out.isAfter(maxT)) maxT = out;

                    Point2D p1 = getCoordinates(startSt);
                    Point2D p2 = getCoordinates(endSt);

                    if (segments.stream().noneMatch(s -> s.matches(startSt, endSt))) {
                        boolean isDouble = parts[3].toLowerCase().contains("double");
                        segments.add(new VisualSegment(startSt, endSt, p1, p2, isDouble));
                    }
                    vt.addMovement(in, out, p1, p2, startSt, endSt);
                    hasData = true;
                } catch (Exception e) {}
            }

            if (hasData) {
                // Injeta Delay Inicial se existir
                ConflictInfo conflict = conflictRegistry.get(train.getTrainId());
                if (conflict != null && !vt.movements.isEmpty()) {
                    vt.initialDelayMinutes = conflict.delayMinutes;
                    vt.hasInitialConflict = true;
                    LocalTime realStart = vt.movements.get(0).start;
                    vt.scheduledStart = realStart.minusMinutes(conflict.delayMinutes);
                }
                allTrains.add(vt);
            }
        }

        this.simulationTime = (minT == LocalTime.MAX) ? LocalTime.of(8, 0) : minT.minusMinutes(30);
        this.maxSimulationTime = maxT.plusMinutes(30);

        autoCameraMode = true;
        btnAutoCam.setSelected(true);
        scale = 0.5; translateX = 0; translateY = 0;
        updateCameraLogic();
        scale = targetScale; translateX = targetTranslateX; translateY = targetTranslateY;
        updateFrame();

        addLog("Rede carregada. " + segments.size() + " segmentos.", false);
    }

    public void startAnimation() {
        if (timer != null) timer.stop();
        if (allTrains.isEmpty()) return;

        timer = new AnimationTimer() {
            private long lastUpdate = 0;

            @Override
            public void handle(long now) {
                if (lastUpdate == 0) { lastUpdate = now; return; }
                double elapsed = (now - lastUpdate) / 1_000_000_000.0;
                lastUpdate = now;

                if (simulationTime != null && !isFinished) {
                    if (isSlowMotionReplay && System.currentTimeMillis() > slowMotionEndTime) {
                        isSlowMotionReplay = false;
                        speedFactor = userSpeedSetting;
                        conflictFocusTrain = null;
                        addLog("Velocidade normal restaurada.", false);
                    }

                    checkDepartures();

                    if (!isPausedByConflict && !isSlowMotionReplay) {
                        checkForConflicts();
                    }

                    if (!isPausedByConflict) {
                        if (simulationTime.isAfter(maxSimulationTime)) {
                            isFinished = true;
                            addLog("Simulação Terminada.", false);
                        } else {
                            long secondsToAdd = (long) (elapsed * speedFactor);
                            simulationTime = simulationTime.plusSeconds(secondsToAdd);
                        }
                    }
                }
                updateCameraLogic();
                applyCameraSmoothing();
                updateFrame();
            }
        };
        timer.start();
    }

    private void checkDepartures() {
        for (VisualTrain vt : allTrains) {
            if (vt.movements.isEmpty()) continue;
            LocalTime refStart = (vt.scheduledStart != null) ? vt.scheduledStart : vt.movements.get(0).start;
            long minToStart = ChronoUnit.MINUTES.between(simulationTime, refStart);

            if (minToStart >= 0 && minToStart <= 15 && !vt.notifiedStart) {
                addLog("Partida: " + vt.train.getTrainId() + " (" + minToStart + " min)", false);
                vt.notifiedStart = true;
            }
        }
    }

    private void checkForConflicts() {
        for (VisualTrain vt : allTrains) {
            // Caso 1: Atraso Inicial
            if (vt.hasInitialConflict &&
                    !simulationTime.isBefore(vt.scheduledStart) &&
                    simulationTime.isBefore(vt.movements.get(0).start) &&
                    !vt.isWaitNotified) {

                triggerConflictPause(vt, "Atraso na partida (" + vt.initialDelayMinutes + " min) - Via ocupada");
                vt.isWaitNotified = true;
                break;
            }

            // Caso 2: Espera no meio
            if (vt.isWaitingBetweenStations(simulationTime) && !vt.isWaitNotified) {
                triggerConflictPause(vt, "Cruzamento / Gestão de Tráfego");
                vt.isWaitNotified = true;
                break;
            }

            if (!vt.hasInitialConflict && !vt.isWaitingBetweenStations(simulationTime)) {
                vt.isWaitNotified = false;
            }
        }
    }

    private void triggerConflictPause(VisualTrain t, String reason) {
        if (isPausedByConflict) return;

        isPausedByConflict = true;
        conflictFocusTrain = t;
        speedFactor = 0;

        Label desc = (Label) conflictPanel.lookup("#conflictDesc");
        if(desc != null) {
            desc.setText("COMBOIO: " + t.train.getTrainId() + "\nLOCAL: " + t.getCurrentLocationName(simulationTime) +
                    "\nMOTIVO: " + reason + "\n\nA simulação foi pausada automaticamente.");
        }

        addLog("⚠ CONFLITO CRÍTICO: " + t.train.getTrainId(), true);
        conflictPanel.setVisible(true);
        conflictPanel.toFront();

        autoCameraMode = false;
        Point2D p = t.getPosition(simulationTime);
        if (p != null) {
            targetScale = 2.0;
            targetTranslateX = (getWidth()/2.0) - (p.getX() * targetScale);
            targetTranslateY = (getHeight()/2.0) - (p.getY() * targetScale);
        }
    }

    private void updateFrame() {
        GraphicsContext gc = canvas.getGraphicsContext2D();
        double w = getWidth(); double h = getHeight();
        gc.setFill(Color.web("#0f172a"));
        gc.fillRect(0, 0, w, h);
        gc.save();
        gc.translate(translateX, translateY);
        gc.scale(scale, scale);
        double viewScale = 1.0 / Math.max(0.3, scale);

        gc.setLineCap(javafx.scene.shape.StrokeLineCap.ROUND);

        for (VisualSegment s : segments) {
            double width = (s.isDouble ? 4.0 : 2.5) * viewScale;
            gc.setStroke(Color.rgb(255,255,255,0.1));
            gc.setLineWidth(width + 2);
            gc.strokeLine(s.p1.getX(), s.p1.getY(), s.p2.getX(), s.p2.getY());
            Color c = s.isDouble ? Color.web("#3b82f6") : Color.web("#f59e0b");
            if (isPausedByConflict) c = c.darker().desaturate();
            gc.setStroke(c);
            gc.setLineWidth(width);
            gc.strokeLine(s.p1.getX(), s.p1.getY(), s.p2.getX(), s.p2.getY());
        }

        Set<String> drawn = new HashSet<>();
        for (VisualSegment s : segments) {
            drawStation(gc, s.origName, s.p1, viewScale, drawn);
            drawStation(gc, s.destName, s.p2, viewScale, drawn);
        }

        for (VisualTrain t : allTrains) drawTrain(gc, t, viewScale);
        gc.restore();

        if (simulationTime != null) clockLabel.setText(simulationTime.format(DateTimeFormatter.ofPattern("HH:mm:ss")));
    }

    private void drawStation(GraphicsContext gc, String name, Point2D pos, double vs, Set<String> drawn) {
        if (drawn.contains(name)) return;
        drawn.add(name);
        double r = 3.5 * vs;
        gc.setFill(Color.WHITE);
        gc.fillOval(pos.getX() - r, pos.getY() - r, r*2, r*2);
        if (scale > 0.4) {
            gc.setFont(Font.font("Arial", 10 * vs));
            gc.setFill(Color.web("#94a3b8"));
            gc.fillText(name, pos.getX() + r + 4, pos.getY() + 3*vs);
        }
    }

    private void drawTrain(GraphicsContext gc, VisualTrain t, double vs) {
        Point2D p = t.getPosition(simulationTime);
        if (p == null) return;

        boolean waiting = t.isWaitingOrDelayed(simulationTime);
        boolean isFocus = (t == conflictFocusTrain);

        if (isPausedByConflict && !isFocus) gc.setGlobalAlpha(0.2);

        double r = (isFocus ? 12.0 : 7.0) * vs;
        Color c = waiting ? Color.web("#ef4444") : Color.web("#10b981");

        if (waiting || isFocus) {
            double pulse = r * (1.3 + 0.3 * Math.sin(System.currentTimeMillis() / 100.0));
            gc.setStroke(Color.web("#ef4444", 0.7));
            gc.setLineWidth(2 * vs);
            gc.strokeOval(p.getX() - pulse, p.getY() - pulse, pulse*2, pulse*2);
        }

        gc.setFill(c);
        gc.setEffect(new DropShadow(8 * vs, c));
        gc.fillOval(p.getX() - r, p.getY() - r, r*2, r*2);
        gc.setEffect(null);

        if (scale > 0.5 || isFocus || waiting) {
            gc.setFill(Color.WHITE);
            gc.setFont(Font.font("Arial", FontWeight.BOLD, 10 * vs));
            gc.fillText(t.train.getTrainId(), p.getX() + r + 2, p.getY() - r);
        }
        gc.setGlobalAlpha(1.0);
    }

    private void updateCameraLogic() {
        if (conflictFocusTrain != null && isPausedByConflict) return;

        if (!autoCameraMode) return;

        List<Point2D> targets = new ArrayList<>();
        if (simulationTime != null) {
            for (VisualTrain vt : allTrains) {
                if (vt.isActive(simulationTime) || vt.hasInitialConflict) {
                    Point2D p = vt.getPosition(simulationTime);
                    if (p != null) targets.add(p);
                }
            }
        }
        if (targets.isEmpty()) return;

        double minX = Double.MAX_VALUE, maxX = -Double.MAX_VALUE, minY = Double.MAX_VALUE, maxY = -Double.MAX_VALUE;
        for (Point2D p : targets) {
            minX = Math.min(minX, p.getX()); maxX = Math.max(maxX, p.getX());
            minY = Math.min(minY, p.getY()); maxY = Math.max(maxY, p.getY());
        }
        double pad = 150;
        double cw = Math.max(100, maxX - minX);
        double ch = Math.max(100, maxY - minY);
        double sx = (getWidth() - pad) / cw;
        double sy = (getHeight() - pad) / ch;
        targetScale = Math.max(0.3, Math.min(Math.min(sx, sy), 1.5));
        targetTranslateX = (getWidth()/2.0) - ((minX + cw/2.0) * targetScale);
        targetTranslateY = (getHeight()/2.0) - ((minY + ch/2.0) * targetScale);
    }

    private void applyCameraSmoothing() {
        double smooth = (isPausedByConflict) ? 0.1 : 0.05;
        scale += (targetScale - scale) * smooth;
        translateX += (targetTranslateX - translateX) * smooth;
        translateY += (targetTranslateY - translateY) * smooth;
    }

    private void setupInteraction() {
        canvasPane.setOnScroll(e -> {
            if (!isPausedByConflict) { autoCameraMode = false; btnAutoCam.setSelected(false); targetScale *= (e.getDeltaY() > 0 ? 1.1 : 0.9); }
        });
        canvasPane.setOnMousePressed(e -> { lastMouseX = e.getX(); lastMouseY = e.getY(); });
        canvasPane.setOnMouseDragged(e -> {
            if (!isPausedByConflict) { autoCameraMode = false; btnAutoCam.setSelected(false); targetTranslateX += (e.getX() - lastMouseX); targetTranslateY += (e.getY() - lastMouseY); lastMouseX = e.getX(); lastMouseY = e.getY(); updateFrame(); }
        });
    }

    private Button createGlassButton(String text) {
        Button btn = new Button(text);
        btn.setStyle("-fx-background-color: rgba(255, 255, 255, 0.1); -fx-text-fill: white; -fx-font-weight: bold; -fx-min-width: 30px; -fx-background-radius: 5; -fx-border-color: rgba(255,255,255,0.2);");
        return btn;
    }

    public void setSpeedFactor(double f) { userSpeedSetting = f; if(!isSlowMotionReplay && !isPausedByConflict) speedFactor = f; }
    public void stopAnimation() { if(timer != null) timer.stop(); }
    private void manualZoom(double f) { autoCameraMode = false; btnAutoCam.setSelected(false); targetScale *= f; }

    // --- HELPER CLASSES ---
    private static class ConflictInfo {
        String station; int delayMinutes;
        ConflictInfo(String s, int d) { this.station = s; this.delayMinutes = d; }
    }

    private static class VisualSegment {
        String origName, destName; Point2D p1, p2; boolean isDouble;
        VisualSegment(String s, String e, Point2D p1, Point2D p2, boolean d) { this.origName = s; this.destName = e; this.p1 = p1; this.p2 = p2; this.isDouble = d; }
        boolean matches(String s, String e) { return (origName.equalsIgnoreCase(s) && destName.equalsIgnoreCase(e)) || (origName.equalsIgnoreCase(e) && destName.equalsIgnoreCase(s)); }
    }

    private static class VisualTrain {
        Train train;
        List<VisualMovement> movements = new ArrayList<>();
        boolean hasInitialConflict = false;
        int initialDelayMinutes = 0;
        LocalTime scheduledStart = null;
        boolean notifiedStart = false;
        boolean isWaitNotified = false;

        VisualTrain(Train t) { this.train = t; }

        void addMovement(LocalTime s, LocalTime e, Point2D p1, Point2D p2, String st1, String st2) {
            movements.add(new VisualMovement(s, e, p1, p2, st1, st2));
            movements.sort(Comparator.comparing(m -> m.start));
        }

        boolean isWaitingOrDelayed(LocalTime t) {
            if (t == null || movements.isEmpty()) return false;
            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) return true;
            return isWaitingBetweenStations(t);
        }

        boolean isWaitingBetweenStations(LocalTime t) {
            for (int i = 0; i < movements.size() - 1; i++) {
                if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i+1).start)) return true;
            }
            return false;
        }

        boolean isActive(LocalTime t) {
            if (t == null || movements.isEmpty()) return false;
            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) return true;
            for (VisualMovement m : movements) if (!t.isBefore(m.start) && !t.isAfter(m.end)) return true;
            return false;
        }

        Point2D getPosition(LocalTime t) {
            if (t == null || movements.isEmpty()) return null;

            if (hasInitialConflict && !t.isBefore(scheduledStart) && t.isBefore(movements.get(0).start)) {
                if (java.time.Duration.between(t, movements.get(0).start).toMinutes() <= 30) return movements.get(0).p1;
                return null;
            }

            for (VisualMovement m : movements) {
                if (!t.isBefore(m.start) && !t.isAfter(m.end)) {
                    long totalSeconds = java.time.Duration.between(m.start, m.end).getSeconds();
                    long currentSeconds = java.time.Duration.between(m.start, t).getSeconds();
                    double r = (totalSeconds <= 0) ? 1.0 : (double) currentSeconds / totalSeconds;
                    return new Point2D(m.p1.getX() + (m.p2.getX() - m.p1.getX()) * r, m.p1.getY() + (m.p2.getY() - m.p1.getY()) * r);
                }
            }

            for (int i = 0; i < movements.size() - 1; i++) {
                if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i + 1).start)) return movements.get(i).p2;
            }

            if (!movements.isEmpty() && t.isBefore(movements.get(0).start)) {
                LocalTime ref = hasInitialConflict ? scheduledStart : movements.get(0).start;
                if (java.time.Duration.between(t, ref).toMinutes() <= 15) return movements.get(0).p1;
            }
            return null;
        }

        String getCurrentLocationName(LocalTime t) {
            if (t == null || movements.isEmpty()) return "?";
            if (hasInitialConflict && t.isBefore(movements.get(0).start)) return movements.get(0).fromStation;
            for (int i = 0; i < movements.size() - 1; i++) {
                if (t.isAfter(movements.get(i).end) && t.isBefore(movements.get(i+1).start)) return movements.get(i).destStation;
            }
            return "Em linha";
        }
    }

    private static class VisualMovement {
        LocalTime start, end; Point2D p1, p2; String fromStation, destStation;
        VisualMovement(LocalTime s, LocalTime e, Point2D p1, Point2D p2, String st1, String st2) { this.start = s; this.end = e; this.p1 = p1; this.p2 = p2; this.fromStation = st1; this.destStation = st2; }
    }
}